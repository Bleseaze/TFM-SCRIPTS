--Chicken Puzzle TFM--


--- OUTPUT
---
--- This lua script is a compilation of other scripts.
--- It was generated by pshy's merging script.
--- https://framagit.org/Pshy/pshy.tfm.lua
--- version v0.6.9
--
__PSHY_VERSION__ = "v0.6.9"
__PSHY_TIME__ = "1644966650.9062374"
print(" ")
--- pshy_merge.py
--
-- This module is used by `combine.py` to merge TFM modules.
--
-- Calls `eventInit()` when all scripts have been loaded.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @hardmerge
pshy = pshy or {}
--- Help Page
pshy.help_pages = pshy.help_pages or {}						-- touching the help_pages table
pshy.help_pages["pshy_merge"] = {title = "Merging (Modules)", text = "This module merge other modules, and can enable or disable them at any moment.", commands = {}}
--- Module Settings:
__PSHY_TFM_API_VERSION__ = "0.28"					-- The last tfm api version this script was made for.
pshy.merge_days_before_update_request_1	= 14		-- How many days old the script should be before suggesting an update. `nil` to disable.
pshy.merge_days_before_update_request_2	= 30		-- How many days old the script should be before requesting an update. `nil` to disable.
pshy.merge_days_before_update_request_3	= nil		-- How many days old the script should be before refusing to start. `nil` to disable.
--- Internal Use:
pshy.merge_has_module_began = false
pshy.merge_has_finished	= false						-- did merging finish
pshy.merge_pending_regenerate = false
pshy.commands = pshy.commands or {}					-- touching the commands table
pshy.modules = {}									-- map of module tables (key is name)
pshy.modules_list = {}								-- list of module tables (in include order)
pshy.events = {}									-- map of event function lists (events[event_name][function_index])
pshy.events_module_names = {}						-- corresponding module names for entries in `pshy.events`
pshy.merge_minimize_events = {}						-- event that require to be fast and not to have all the features
pshy.merge_minimize_events["eventKeyboard"] = true
--- Create a module table and returns it.
-- @private
function pshy.merge_CreateModule(module_name)
	assert(pshy.merge_has_finished == false, "pshy.merge_CreateModule(): Merging have already been finished!")
	local new_module = {}
	pshy.modules[module_name] = new_module
	table.insert(pshy.modules_list, new_module)
	new_module.index = #pshy.modules_list			-- index of the event in `pshy.modules_list`
	new_module.name = module_name					-- index of the event in `pshy.modules`
	new_module.events = {}							-- map of events (function name -> function)
	new_module.event_count = 0						-- counter for event functions
	new_module.eventModuleEnabled = nil				-- function called when the module is enabled
	new_module.eventModuleDisabled = nil			-- function called when the module is disabled
	new_module.enabled = true						-- index of the event in `pshy.modules`
	return new_module
end
--- Begin a module.
-- @private
-- Call before a new module's code, in the merged source.
function pshy.merge_ModuleBegin(module_name)
	assert(pshy.merge_has_module_began == false, "pshy.merge_ModuleBegin(): A previous module have not been ended!")
	assert(pshy.merge_has_finished == false, "pshy.merge_MergeBegin(): Merging have already been finished!")
	pshy.merge_has_module_began = true
	return pshy.merge_CreateModule(module_name)
	--print("[Merge] Loading " .. module_name .. "...")
end
--- End a module.
-- @private
-- Call after a module's code, in the merged source.
function pshy.merge_ModuleEnd()
	assert(pshy.merge_has_module_began == true, "pshy.merge_ModuleEnd(): No module to end!")
	assert(pshy.merge_has_finished == false, "pshy.merge_MergeEnd(): Merging have already been finished!")
	pshy.merge_has_module_began = false
	local mod = pshy.modules_list[#pshy.modules_list]
	-- `Enable` and `Disable` events
	if _G["eventModuleEnabled"] then
		assert(type(_G["eventModuleEnabled"]) == "function")
		mod.eventModuleEnabled = _G["eventModuleEnabled"]
		_G["eventModuleEnabled"] = nil
	end
	if _G["eventModuleDisabled"] then
		assert(type(_G["eventModuleDisabled"]) == "function")
		mod.eventModuleDisabled = _G["eventModuleDisabled"]
		_G["eventModuleDisabled"] = nil
	end
	-- find used event names
	for e_name, e in pairs(_G) do
		if type(e) == "function" and string.sub(e_name, 1, 5) == "event" then
			mod.events[e_name] = e
			mod.event_count = mod.event_count + 1
		end
	end
	--
	if mod.event_count == 0 then
		mod.enabled = false
	end
	-- remove the events from _G
	for e_name in pairs(mod.events) do
		_G[e_name] = nil
	end
	--print("[Merge] Module loaded.")
end
--- Final step for merging modules.
-- Call this when you're done putting modules together.
-- @private
function pshy.merge_Finish()
	assert(pshy.merge_has_module_began == false, "pshy.merge_Finish(): A previous module have not been ended!")
	assert(pshy.merge_has_finished == false, "pshy.merge_Finish(): Merging have already been finished!")
	pshy.merge_has_finished = true
	pshy.merge_GenerateEvents()
	local event_count = pshy.merge_CreateEventFuntions()
	if _G["eventInit"] then
		eventInit()
	end
	print(string.format("<vp>[Merge] </vp><v>Created <ch2>%d events</ch2> for <ch>%d modules</ch>.", event_count, #pshy.modules_list))
end
--- Get a map of event function lists (events.event_names.functions).
function pshy.merge_GetEventsFunctions()
	--print_debug("pshy.merge_GetEventsFunctions()")
	local events = pshy.events
	local events_module_names = pshy.events_module_names
	-- clear the tables
	for e_name, e_list in pairs(events) do
		while #e_list > 0 do
			table.remove(e_list, #e_list)
		end
	end
	for e_name, e_list in pairs(events_module_names) do
		while #e_list > 0 do
			table.remove(e_list, #e_list)
		end
	end
	--local events = {}
	--local events_module_names = {}
	for i_mod, mod in ipairs(pshy.modules_list) do
		if mod.enabled then
			for e_name, e in pairs(mod.events) do
				events[e_name] = events[e_name] or {}
				table.insert(events[e_name], e)
				events_module_names[e_name] = events_module_names[e_name] or {}
				table.insert(events_module_names[e_name], mod.name)
			end
		end
	end
	return events, events_module_names
end
--- Create the event functions.
-- @TODO: test performances against ipairs.
-- @TODO: test performances with inlining the function call.
function pshy.merge_CreateEventFuntions()
	--print_debug("pshy.merge_CreateEventFuntions()")
	local event_count = 0
	local pshy_events = pshy.events
	for e_name, e_func_list in pairs(pshy_events) do
		if #e_func_list > 0 then
			event_count = event_count + 1
			if not pshy.merge_minimize_events[e_name] then
				_G[e_name] = function(...)
					-- Event functions's code
					local rst = nil
					--for i_func = 1, #e_func_list do
						--rst = e_func_list[i_func](...)
					for i_func, func in ipairs(e_func_list) do
						rst = func(...)
						if rst ~= nil then
							break
						end
					end
					if pshy.merge_pending_regenerate then
						--print_debug("event regeneration was pending")
						pshy.merge_GenerateEvents()
						pshy.merge_pending_regenerate = false
					end
				end
			else
				-- this is a minimum optimized version of the above
				_G[e_name] = function(...)
					for i_func, func in ipairs(e_func_list) do
						func(...)
					end
				end
			end
		end
	end
	-- return the events count
	return event_count
end
--- Generate the global events.
function pshy.merge_GenerateEvents()
	--print_debug("pshy.merge_GenerateEvents()")
	assert(pshy.merge_has_module_began == false, "pshy.merge_GenerateEvents(): A previous module have not been ended!")
	assert(pshy.merge_has_finished == true, "pshy.merge_GenerateEvents(): Merging have not been finished!")
	-- create list of events
	--pshy.events, pshy.events_module_names = pshy.merge_GetEventsFunctions()
	pshy.merge_GetEventsFunctions()
	pshy.merge_CreateEventFuntions()
	return #pshy.events
end
--- Enable a list of modules.
function pshy.merge_EnableModules(module_list)
	--print_debug("pshy.merge_EnableModules(module_list)")
	for i, module_name in pairs(module_list) do
		local mod = pshy.modules[module_name]
		if mod then
			if not mod.enabled and mod.eventModuleEnabled then
				mod.eventModuleEnabled()
			end
			mod.enabled = true
			pshy.merge_pending_regenerate = true
		else
			print("<r>[Merge] Cannot enable module " .. module_name .. "! (not found)</r>")
		end
	end
end
--- Disable a list of modules.
function pshy.merge_DisableModules(module_list)
	--print_debug("pshy.merge_DisableModules(module_list)")
	for i, module_name in pairs(module_list) do
		local mod = pshy.modules[module_name]
		if mod then
			if mod.enabled and mod.eventModuleDisabled then
				mod.eventModuleDisabled()
			end
			mod.enabled = false
			pshy.merge_pending_regenerate = true
		else
			print("<r>[Merge] Cannot disable module " .. module_name .. "! (not found)</r>")
		end
	end
end
--- Enable a module.
-- @public
function pshy.merge_EnableModule(mname)
	--print_debug("pshy.merge_EnableModule(%s)", mname)
	local mod = pshy.modules[mname]
	assert(mod, "Unknown " .. mname .. "module.")
	if mod.enabled then
		return false, "Already enabled."
	end
	mod.enabled = true
	if mod.eventEnableModule then
		mod.eventEnableModule()
	end
	pshy.merge_pending_regenerate = true
end
--- Disable a module.
-- @public
function pshy.merge_DisableModule(mname)
	--print_debug("pshy.merge_DisableModule(%s)", mname)
	local mod = pshy.modules[mname]
	assert(mod, "Unknown " .. mname .. " module.")
	if not mod.enabled then
		return false, "Already disabled."
	end
	mod.enabled = false
	if mod.eventDisableModule then
		mod.eventDisableModule()
	end
	pshy.merge_pending_regenerate = true
end
--- !modules
function pshy.merge_ChatCommandModules(user, event_name)
	tfm.exec.chatMessage("<r>[Merge]</r> Modules (in load order):", user)
	for i_module, mod in pairs(pshy.modules_list) do
		if not event_name or mod.events[event_name] then
			local line = (mod.enabled and "<v>" or "<g>") ..tostring(mod.index) .. "\t" .. mod.name
			if mod.event_count > 0 then
				line = line .. " \t" .. tostring(mod.event_count) .. " events"
			end
			tfm.exec.chatMessage(line, user)
		end
	end
end
pshy.commands["modules"] = {func = pshy.merge_ChatCommandModules, desc = "see a list of loaded modules", argc_min = 0, argc_max = 1, arg_types = {"string"}, arg_names = {"event_name"}}
pshy.help_pages["pshy_merge"].commands["modules"] = pshy.commands["modules"]
--- !enablemodule
function pshy.merge_ChatCommandModuleenable(user, mname)
	tfm.exec.chatMessage("[Merge] Enabling " .. mname)
	return pshy.merge_EnableModule(mname)
end
pshy.commands["enablemodule"] = {func = pshy.merge_ChatCommandModuleenable, desc = "enable a module", argc_min = 1, argc_max = 1, arg_types = {"string"}}
pshy.help_pages["pshy_merge"].commands["enablemodule"] = pshy.commands["enablemodule"]
--- !disablemodule
function pshy.merge_ChatCommandModuledisable(user, mname)
	tfm.exec.chatMessage("[Merge] Disabling " .. mname)
	return pshy.merge_DisableModule(mname)
end
pshy.commands["disablemodule"] = {func = pshy.merge_ChatCommandModuledisable, desc = "disable a module", argc_min = 1, argc_max = 1, arg_types = {"string"}}
pshy.help_pages["pshy_merge"].commands["disablemodule"] = pshy.commands["disablemodule"]
--- Perform initial misc checks and actions.
function pshy.merge_Init()
	print("<v>Pshy version <ch>" .. tostring(__PSHY_VERSION__) .. "</ch></v>")
	-- check release age
	local release_days = __PSHY_TIME__ / 60 / 60 / 24
	local current_days = os.time() / 1000 / 60 / 60 / 24
	local days_old = current_days - release_days
	if pshy.merge_days_before_update_request_3 and days_old > pshy.merge_days_before_update_request_3 then
		print(string.format("<r>This build is <vi>%d days</vi> old. Please consider obtaining a newer version.</r>", days_old))
		error(string.format("<r>This build is <vi>%d days</vi> old. Please consider obtaining a newer version.</r>", days_old))
	elseif pshy.merge_days_before_update_request_2 and days_old > pshy.merge_days_before_update_request_2 then
		print(string.format("<o>This build is <r>%d days</r> old. Please obtain a newer version as soon as possible.</o>", days_old))
	elseif pshy.merge_days_before_update_request_1 and days_old > pshy.merge_days_before_update_request_1 then
		print(string.format("<j>This build is <o>%d days</o> old. An update may be available.</j>", days_old))
	else
		print(string.format("<v>This build is <ch>%d days</ch> old.</v>", days_old))
	end
	if pshy.merge_days_before_update_request_3 and days_old > pshy.merge_days_before_update_request_3 / 2 then
		print(string.format("<r>/!\\ This script will not start after being %d days old.</r>", pshy.merge_days_before_update_request_3))
	end
	-- check tfm api version
	local expected_tfm_api_version_numbers = {}
	for number_str in string.gmatch(__PSHY_TFM_API_VERSION__, "([^\.]+)") do
		table.insert(expected_tfm_api_version_numbers, tonumber(number_str))
	end
	local current_tfm_api_version_numbers = {}
	for number_str in string.gmatch(tfm.get.misc.apiVersion, "([^\.]+)") do
		table.insert(current_tfm_api_version_numbers, tonumber(number_str))
	end
	if current_tfm_api_version_numbers[1] and expected_tfm_api_version_numbers[1] ~= current_tfm_api_version_numbers[1] then
		print("<o>The TFM LUA API had a major update, an update of the current script may be available for this new version.</o>")
	elseif current_tfm_api_version_numbers[2] and expected_tfm_api_version_numbers[2] ~= current_tfm_api_version_numbers[2] then
		print("<j>The TFM LUA API had a minor update, an update of the current script may be available for this new version.</j>")
	end
end
-- Create pshy_merge.lua module
pshy.merge_Init()
pshy.merge_CreateModule("pshy_merge.lua")
local new_mod = pshy.merge_ModuleBegin("pshy_print.lua")
function new_mod.Content()
--- pshy_print.lua
--
-- Custom print functions.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require_priority HARDMERGE
pshy = pshy or {}
function printf(format, ...)
	print(string.format(format, ...))
end
function print_debug(format, ...)
	print("<bv>DEBUG: </bv>" .. string.format(format, ...))
end
function print_info(format, ...)
	print("<ch>INFO: </ch>" .. string.format(format, ...))
end
function print_warn(format, ...)
	print("<o>WARN: </o>" .. string.format(format, ...))
end
function print_error(format, ...)
	print("<r>ERROR: </r>" .. string.format(format, ...))
end
function print_critical(format, ...)
	print("<r>CRITICAL: </r>" .. string.format(format, ...))
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_rotation.lua")
function new_mod.Content()
--- pshy_rotation.lua
--
-- Adds a table type that can be used to create random rotations.
--
-- A rotation is a table with the folowing fields:
--	- items: List of items to be randomly returned.
--	- next_indices: Private list of item indices that have not been done yet.
--	- is_random: `false` to disable randomness.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @hardmerge
pshy = pshy or {}
--- Create a rotation.
-- @public
-- You can then add items in its `items` field.
function pshy.rotation_Create()
	local rotation = {}
	rotation.items = {}
	return rotation
end
--- Reset a rotation.
-- @public
-- Its state will be back as if you had never poped items from it.
function pshy.rotation_Reset(rotation)
	assert(type(rotation) == "table", "unexpected type " .. type(rotation))
	rotation.next_indices = {}
	if #rotation.items > 0 then
		for i = 1, #rotation.items do
			table.insert(rotation.next_indices, i)
		end
	end
end
--- Get a random item from a rotation.
-- @param rotation The rotation table.
-- @return A random item from the rotation.
function pshy.rotation_Next(rotation)
	assert(type(rotation) == "table", "unexpected type " .. type(rotation))
	assert(type(rotation.items) == "table", "rotation table had no item")
	if #rotation.items == 0 then
		return nil
	end
	-- reset the rotation if needed
	rotation.next_indices = rotation.next_indices or {}
	if #rotation.next_indices == 0 then
		pshy.rotation_Reset(rotation)
	end
	-- pop the item
	local i_index = (rotation.is_random == false) and 1 or math.random(#rotation.next_indices)
	local item = rotation.items[rotation.next_indices[i_index]]
	table.remove(rotation.next_indices, i_index)
	-- returning
	return item
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_utils_tables.lua")
function new_mod.Content()
--- pshy_utils_tables.lua
--
-- Basic functions related to LUA tables.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @hardmerge
pshy = pshy or {}
--- Copy a table.
-- @param t The table to copy.
-- @return a copy of the table.
-- disabled because not used
--function pshy.TableCopy(t)
--	assert(type(t) == "table")
--	local new_table = {}
--	for key, value in pairs(t) do
--		new_table[key] = value
--	end
--	return new_table
--end
--- Copy a table, recursively.
-- @param t The table to copy.
-- @return a copy of the table.
function pshy.TableDeepCopy(t)
	assert(type(t) == "table")
	local new_table = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			value = pshy.TableDeepCopy(value)
		end
		new_table[key] = value
	end
	return new_table
end
--- Copy a list table.
-- @param t The list table to copy.
-- @return a copy of the list table.
function pshy.ListCopy(t)
	assert(type(t) == "table")
	local new_table = {}
	for key, value in ipairs(t) do
		table.insert(new_table, value)
	end
	return new_table
end
--- Get a table's keys as a list.
-- @public
-- @param t The table.
-- @return A list of the keys from the given table.
function pshy.TableKeys(t)
	local keys = {}
	for key in pairs(t) do
		table.insert(keys, key)
	end
	return keys
end
--- Get a table's keys as a sorted list.
-- @public
-- @param t The table.
-- @return A list of the keys from the given table, sorted.
function pshy.TableSortedKeys(t)
	local keys = pshy.TableKeys(t)
	table.sort(keys)
	return keys
end
--- Count the keys in a table.
-- @public
-- @param t The table.
-- @return The count of keys in the given table.
function pshy.TableCountKeys(t)
	local count = 0
	for key, value in pairs(t) do
		count = count + 1
	end
	return count
end
--- Check if a table has any key.
-- @public
-- @param t The table.
-- @return true if the table contains a key.
-- disabled because not used
--function pshy.TableHasAnyKey(t)
--	for key in pairs(t) do
--		return true
--	end
--	return false
--end
--- Remove duplicates in a sorted list.
-- @return Count of removed items.
function pshy.SortedListRemoveDuplicates(t)
	local prev_size = #t
	local i = #t - 1
	while i >= 1 do
		if t[i] == t[i + 1] then
			table.remove(t, i + 1)
		end
		i = i - 1
	end
	return prev_size - #t
end
--- Remove duplicates in a table.
-- @return Count of removed items.
-- disabled because not used
--function pshy.TableRemoveDuplicates(t)
--	local prev_size = #t
--	local keys = {}
--	local i = #t
--	while i >= 1 do
--		if keys[t[i]] then
--			table.remove(t, i + 1)
--		else
--			keys[t[i]] = true
--		end
--		i = i - 1
--	end
--	return prev_size - #t
--end
--- Append a list to another.
-- @param dst_list The list receiving the new items.
-- @param src_list The list containing the items to appen to the other list.
function pshy.ListAppend(dst_list, src_list)
	assert(type(dst_list) == "table")
	assert(type(dst_list) == "table")
	for i_item, item in ipairs(src_list) do
		table.insert(dst_list, item)
	end
end
--- Get a random key from a table.
-- @param t The table.
-- disabled because not used
--function pshy.TableGetRandomKey(t)
--	local keylist = {}
--	for k in pairs(t) do
--	    table.insert(keylist, k)
--	end
--	return keylist[math.random(#keylist)]
--end
--- Count a value in a table.
-- @param t The table to count from.
-- @param v The value to search.
function pshy.TableCountValue(t, v)
	local count = 0
	for key, value in pairs(t) do
		if value == v then
			count = count + 1
		end
	end
	return count
end
--- Remove all instances of a value from a list.
-- @param l List to remove from.
-- @param v Value to remove.
function pshy.ListRemoveValue(l, v)
	for i = #l, 1, -1 do
		if l[i] == v then
			table.remove(l, i)
		end
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_colors.lua")
function new_mod.Content()
--- pshy_colors.lua
--
-- Simple enumeration of color codes
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
-- @hardmerge
pshy = pshy or {}
--- Public Map:
pshy.colors = {}
-- primary colors
pshy.colors.red			= 0xff0000
pshy.colors.lime		= 0x00ff00
pshy.colors.blue		= 0x0000ff
-- secondary colors
pshy.colors.yellow		= 0xffff00
pshy.colors.magenta		= 0xff00ff
pshy.colors.cyan		= 0x00ffff
-- greys
pshy.colors.transparent	= 0x000000	-- because TFM may count 0x000000 as transparent.
pshy.colors.black		= 0x010101	-- because TFM may count 0x000000 as transparent.
pshy.colors.grey		= 0x808080
pshy.colors.gray		= 0x808080
pshy.colors.silver		= 0xc0c0c0
pshy.colors.white		= 0xffffff
-- odd
pshy.colors.maroon		= 0x800000
pshy.colors.green		= 0x008000
pshy.colors.navy		= 0x000080
pshy.colors.olive		= 0x808000
pshy.colors.purple		= 0x800080
pshy.colors.teal		= 0x008080
-- common
pshy.colors.aquamarine	= 0x7fffd4
pshy.colors.brown		= 0xa52a2a
pshy.colors.bronze		= 0x967444
pshy.colors.coral		= 0xff7f50
pshy.colors.darkgreen	= 0x006400
pshy.colors.gold		= 0xffd700
pshy.colors.indigo		= 0x4b0082
pshy.colors.lavender	= 0xb2a4d4
pshy.colors.orange		= 0xffa500
pshy.colors.pink		= 0xffc0cb
pshy.colors.tan			= 0xd2b48c
pshy.colors.turquoise	= 0x40e0d0
pshy.colors.violet		= 0x9b26b6
-- TFM
pshy.colors.funcorp		= 0xff8000
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_utils_lua.lua")
function new_mod.Content()
--- pshy_utils_lua.lua
--
-- Basic functions related to LUA.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require pshy_colors.lua
--
-- @hardmerge
pshy = pshy or {}
--- string.isalnum(str)
-- us this instead: `not str:match("%W")`
--- Split a string
-- Ignores empty fields
-- @param str String to split.
-- @param separator Char to split at, default to whitespaces.
-- @param max Max amount of returned strings.
function pshy.StrSplit(str, separator, max)
	assert(type(str) == "string", "str need to be of type string (was " .. type(str) .. ")" .. debug.traceback())
	separator = separator or "%s"
	max = max or -1
	remlen = #str
	local parts = {}
	for part in string.gmatch(str, "([^" .. separator .. "]+)") do
		if max == 1 and remlen >= 0 then
			table.insert(parts, string.sub(str, -remlen))
			return parts
		end
		table.insert(parts, part)
		remlen = remlen - #part - 1
		max = max - 1
	end
	return parts
end
--- Same as pshy.StrSplit but does not ignore empty fields.
function pshy.StrSplit2(str, separator)
	assert(type(str) == "string")
	separator = separator or '%s'
	local fields = {}
	for field, s in string.gmatch(str, "([^".. separator .."]*)(".. separator .."?)") do
		table.insert(fields, field)
		if s == "" then --@TODO: learn about this
			return fields
		end
	end
	return fields
end
--- Convert a string to a boolean.
-- @param string "true" or "false".
-- @return Boolean true or false, or nil.
function pshy.ToBoolean(value)
	if value == "true" then
		return true
	end
	if value == "false" then
		return false
	end
	return nil
end
--- Convert a string to a boolean (andles yes/no and on/off).
-- @param string "true" or "false".
-- @return Boolean true or false, or nil.
function pshy.ToPermissiveBoolean(value)
	if value == "true" or value == "on" or value == "yes" then
		return true
	end
	if value == "false" or value == "off" or value == "no" then
		return false
	end
	return nil
end
--- Interpret a namespace expression (resolve lua path from string)
-- @param path lua path (such as "tfm.enum.bonus")*
-- @return the object represented by path or nil if not found
function pshy.LuaGet(path)
	assert(type(path) == "string", debug.traceback())
	local parts = pshy.StrSplit(path, ".")
	local cur = _G
	for index, value in pairs(parts) do
		possible_int = tonumber(value)
		value = possible_int or value
		cur = cur[value]
		if cur == nil then
			return nil
		end
	end
	return cur
end
--- Set the value to a lua object.
-- The path is created if it does not exist.
-- @param obj_path Lua path to the object.
-- @param value Value to set, any type.
function pshy.LuaSet(obj_path, value)
	assert(type(obj_path) == "string", debug.traceback())
	local parts = pshy.StrSplit(obj_path, ".")
	local cur = _G
	for i_part, part in pairs(parts) do
		possible_int = tonumber(part)
		part = possible_int or part
		if i_part == #parts then
			-- last iteration
			cur[part] = value
			return cur[part]
		end
		cur[part] = cur[part] or {}
		if type(cur) ~= "table" then
			return nil
		end
		cur = cur[part]
	end
	error("unreachable code")
end
--- Get a random key from a table.
-- @param t The table.
function pshy.LuaRandomTableKey(t)
	local keylist = {}
	for k in pairs(t) do
	    table.insert(keylist, k)
	end
	return keylist[math.random(#keylist)]
end
--- Convert a string value to the given type.
-- nil value is not supported for `string` and `player`.
-- @param value String to convert.
-- @param type string representing the type to convert to.
-- @return The converted value.
-- @todo Should t be a table to represent enum keys?
function pshy.ToType(value, t)
	assert(type(value) == "string", "wrong argument type")
	assert(type(t) == "string", "wrong argument type")
	-- string
	if t == "string" then
		return value
	end
	-- player
	if t == "player" then
		return pshy.FindPlayerName(value)
	end
	-- nil
	if value == "nil" then
		return nil
	end
	-- boolean
	if t == "bool" or t == "boolean" then
		return pshy.ToPermissiveBoolean(value)
	end
	-- number
	if t == "number" then
		return tonumber(value)
	end
	-- color
	if t == "color" then
		if pshy.colors[value] then
			return pshy.colors[value]
		end
		t = "hexnumber"
	end
	-- hexnumber
	if t == "hexnumber" then
		if string.sub(value, 1, 1) == '#' then
			value = string.sub(value, 2, #value)
		end
		return tonumber(value, 16)
	end
	-- enums
	local enum = pshy.LuaGet(t)
	if type(enum) == "table" then
		return enum[value]
	end
	-- not supported
	error("type not supported")
end
--- Convert an argument to anoter type automatically.
-- @param value String to convert.
-- @return the same value represented by the best type possible (bool/number/string).
function pshy.AutoType(value)
	assert(type(value) == "string", "wrong argument type")
	local rst
	-- nil
	if value == "nil" then
		return nil
	end
	-- boolean
	if value == "true" then
		return true
	end
	if value == "false" then
		return false
	end
	-- number
	rst = tonumber(value, 10)
	if rst then
		return rst
	end
	-- empty table
	if value == "{}" then
		return {}
	end
	-- tfm enums
	rst = pshy.TFMEnumGet(value)
	if rst then
		return rst
	end
	-- lua object
	rst = pshy.LuaGet(value)
	if rst then
		return rst
	end
	-- color code / hex number
	if string.sub(value, 1, 1) == '#' then
		rst = tonumber(string.sub(value, 2, #value), 16)
		if rst then
			return rst
		end
	end
	-- string
	return value
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_tfm_enum_fix.lua")
function new_mod.Content()
--- pshy_tfm_enum_fix.lua
--
-- Adds missing values to `tfm.enum.shamanObject`.
-- Also fix some errors.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
--
-- @hardmerge
tfm.enum.shamanObject.spirit = 24			-- missing
tfm.enum.shamanObject.bluePortal = 26		-- correct
tfm.enum.shamanObject.orangePortal = 27		-- currently 26 in the API
tfm.enum.shamanObject.fish = 63				-- missing
tfm.enum.shamanObject.oldBox = 96			-- missing but supposed to be removed
tfm.enum.shamanObject.powerOrb = 97			-- missing
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_assert.lua")
function new_mod.Content()
--- pshy_assert.lua
--
-- Cause lua assert to provide more informations.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require_priority WRAPPER
pshy = pshy or {}
--- Custom assert function.
function pshy.assert(condition, message)
	if not condition then
		local error_message = "\n<u><r>ASSERTION FAILED</r></u>"
		if message then
			error_message = error_message .. "\n<b><o>" .. message .. "</o></b>"
		end
		error_message = error_message .. "\n<i><j>" .. debug.traceback() .. "</j></i>"
		if pshy.loader then
			tfm.exec.chatMessage(error_message, pshy.loader)
		end
		error(error_message)
	end
end
assert = pshy.assert
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_mapdb.lua")
function new_mod.Content()
--- pshy_mapdb.lua
--
-- List of maps and rotations.
-- Custom settings may be used by other modules.
--
-- Listed map and rotation tables can have the folowing fields:
--	- begin_func: Function to run when the map started.
--	- end_func: Function to run when the map stopped.
--	- replace_func: Function to run on the map's xml (or name if not present) that is supposed to return the final xml.
--	- autoskip: If true, the map will change at the end of the timer.
--	- duration: Duration of the map.
--	- shamans: Count of shamans (Currently, only 0 is supported to disable the shaman).
--	- xml (maps only): The true map's xml code.
--	- hidden (rotations only): Do not show the rotation is being used to players.
--	- modules: list of module names to enable while the map is playing (to trigger events).
--	- troll: bool telling if the rotation itself is a troll (may help other modules about how to handle the rotation).
--	- unique_items: bool telling if the items are supposed to be unique (duplicates are removed on eventInit).
-- See `pshy_madb_misc_maps.lua` for a more complete list of maps and rotations.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
-- @require pshy_rotation.lua
--
-- @require_priority UTILS
--
-- @TODO: remove dependencies
--- Module Settings:
pshy.mapdb_maps = {}						-- map of maps
pshy.mapdb_rotations = {}					-- map of rotations
--- Map Lists:
-- Vanilla:
pshy.mapdb_maps_vanilla = {}
local deleted_vanilla_maps = {[29] = true, [108] = true, [110] = true, [111] = true, [112] = true, [113] = true, [135] = true, [169] = true, [193] = true, [194] = true, [195] = true, [196] = true, [197] = true, [198] = true, [199] = true}
for i = 0, 210 do
	if not deleted_vanilla_maps[i] then
		table.insert(pshy.mapdb_maps_vanilla, i)
	end
end
--- Test Map:
pshy.mapdb_maps["test"]						= {author = "Test#0801", title = "Test Map", title_color="#ff7700", background_color = "#FF00FF", xml = [[<C><P F="0" shaman_tools="1,33,102,110,111,202,302,402,608,1002,2802,2,2806" MEDATA=";;;;-0;0:::1-"/><Z><S><S T="6" X="400" Y="250" L="120" H="40" P="0,0,0.3,0.2,0,0,0,0"/></S><D><F X="432" Y="218"/><P X="393" Y="230" T="11" P="0,0"/><DC X="362" Y="213"/><DS X="436" Y="107"/></D><O/><L/></Z></C>]]}
pshy.mapdb_maps["error_map"]				= {author = "Error", duration = 20, title = "an error happened", xml = 7893612}
--- Rotation aliases:
local rotation_aliases = {}
rotation_aliases["standard"]		= "P0"
rotation_aliases["protected"]		= "P1"
rotation_aliases["shaman"]			= "P4"
rotation_aliases["art"]				= "P5"
rotation_aliases["mechanisms"]		= "P6"
rotation_aliases["nosham"]			= "P7"
rotation_aliases["no_shaman"]		= "P7"
rotation_aliases["dual_shaman"]		= "P8"
rotation_aliases["misc"]			= "P9"
rotation_aliases["miscellaneous"]	= "P9"
rotation_aliases["racing"]			= "P17"
rotation_aliases["defilante"]		= "P18"
rotation_aliases["racing_test"]		= "P38"
rotation_aliases["thematic"]		= "P66"
--- Basic Rotations.
pshy.mapdb_rotations["vanilla"]						= {desc = "0-210", duration = 120, items = pshy.mapdb_maps_vanilla}
pshy.mapdb_rotations["P0"]							= {desc = "P0 - standard", duration = 120, items = {"#0"}}
pshy.mapdb_rotations["P1"]							= {desc = "P1 - protected", duration = 120, items = {"#1"}}
pshy.mapdb_rotations["P4"]							= {desc = "P4 - shaman", duration = 120, items = {"#4"}}
pshy.mapdb_rotations["P5"]							= {desc = "P5 - art", duration = 120, items = {"#5"}}
pshy.mapdb_rotations["P6"]							= {desc = "P6 - mechanisms", duration = 120, items = {"#6"}}
pshy.mapdb_rotations["P7"]							= {desc = "P7 - no shaman", duration = 60, shamans = 0, items = {"#7"}}
pshy.mapdb_rotations["P8"]							= {desc = "P8 - dual shaman", duration = 60, shamans = 0, items = {"#8"}}
pshy.mapdb_rotations["P9"]							= {desc = "P9 - miscellaneous", duration = 60, shamans = 0, items = {"#9"}}
pshy.mapdb_rotations["P17"]							= {desc = "P17 - racing", duration = 60, shamans = 0, items = {"#17"}}
pshy.mapdb_rotations["P18"]							= {desc = "P18 - defilante", duration = 60, shamans = 0, items = {"#18"}}
pshy.mapdb_rotations["P38"]							= {desc = "P38 - racing test", duration = 60, shamans = 0, items = {"#38"}}
pshy.mapdb_rotations["P66"]							= {desc = "P66 - thematic", duration = 60, shamans = 0, items = {"#66"}}
pshy.mapdb_rotations["transformice"]				= {is_random = false, items = {"vanilla", "#4", "#9", "#5", "#1", "vanilla", "#8", "#6", "#7", "#66", "#0"}}
--- Get a rotation table.
function pshy.mapdb_GetRotation(rotation_name)
	while rotation_aliases[rotation_name] do
		rotation_name = rotation_aliases[rotation_name]
	end
	return pshy.mapdb_rotations[rotation_name]
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_perms.lua")
function new_mod.Content()
--- pshy_perms.lua
--
-- This module adds permission functionalities.
--
-- Main features (also check the settings):
--	- `pshy.loader`: The script launcher.
--	- `pshy.admins`: Set of admin names (use `pshy.authors` to add permanent admins).
--	- `pshy.HavePerm(player_name, permission)`: Check if a player have a permission (always true for admins).
--	- `pshy.perms.everyone`: Set of permissions every player have by default.
--	- `pshy.perms.PLAYER#0000`: Set of permissions the player "PLAYER#0000" have.
--
-- Some players are automatically added as admin after the first eventNewGame or after they joined.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require_priority UTILS
pshy = pshy or {}
--- Module Settings and Public Members:
pshy.loader = string.match(({pcall(nil)})[2], "^(.-)%.")		-- script loader
pshy.admins = {}												-- set of room admins
pshy.admins[pshy.loader] = true									-- should the loader be an admin
pshy.perms = {}													-- map of players's sets of permissions (a perm is a string, preferably with no ` ` nor `.`, prefer `-`, `/` is reserved for future use)
pshy.perms.everyone = {}										-- set of permissions everyone has
pshy.perms.cheats = {}											-- set of permissions everyone has when cheats are enabled
pshy.perms.admins = {}											-- set of permissions room admins have
pshy.perms_auto_admin_admins = true								-- add the game admins as room admin automatically
pshy.perms_auto_admin_moderators = true							-- add the moderators as room admin automatically
pshy.perms_auto_admin_funcorps = true							-- add the funcorps as room admin automatically (from a list, ask to be added in it)
pshy.funcorps = {}												-- set of funcorps who asked to be added, they can use !adminme
pshy.funcorps["Pshy#3752"] = true
pshy.perms_auto_admin_authors = true							-- add the authors of the final modulepack as admin
pshy.authors = {}												-- set of modulepack authors (add them from your module script)
pshy.authors["Pshy#3752"] = true
pshy.funcorp = (tfm.exec.getPlayerSync() ~= nil)				-- false if tribehouse or non-funcorp, true if funcorp features available
pshy.public_room = (string.sub(tfm.get.room.name, 1, 1) ~= "@")	-- limit admin features in public rooms
pshy.private_room = (string.sub(tfm.get.room.name, 1, 1) == "@")
pshy.admin_instructions = {}									-- add instructions to admins
pshy.perms_cheats_enabled = false								-- do players have the perms in `pshy.perms.cheats`
--- Help page:
pshy.help_pages = pshy.help_pages or {}						-- touching the help_pages table
pshy.help_pages["pshy_perms"] = {title = "Permissions", text = "Player permissions are stored in sets such as `pshy.perms.Player#0000`.\n`pshy.perms.everyone` contains default permissions.\nRoom admins from the set `pshy.admins` have all permissions.\n", commands = {}}
--- Internal use:
pshy.commands = pshy.commands or {}				-- touching the commands table
--- Check if a player have a permission.
-- @public
-- @param The name of the player.
-- @param perm The permission name.
-- @return true if the player have the required permission.
function pshy.HavePerm(player_name, perm)
	assert(type(perm) == "string", "permission must be a string")
	if player_name == pshy.loader or pshy.admins[player_name] and ((not pshy.public_room) or pshy.perms.admins[perm] or pshy.perms.cheats[perm]) then
		return true
	end
	if pshy.perms.everyone[perm] or (pshy.perms_cheats_enabled and pshy.perms.cheats[perm]) or (pshy.perms[player_name] and pshy.perms[player_name][perm])then
		return true
	end
	return false
end
--- Add an admin with a reason, and broadcast it to other admins.
-- @private
-- @param new_admin The new room admin's Name#0000.
-- @param reason A message displayed as the reason for the promotion.
function pshy.perms_AddAdmin(new_admin, reason)
	pshy.admins[new_admin] = true
	for an_admin, void in pairs(pshy.admins) do
		tfm.exec.chatMessage("<r>[PshyPerms]</r> " .. new_admin .. " added as a room admin" .. (reason and (" (" .. reason .. ")") or "") .. ".", an_admin)
	end
end
--- Check if a player could me set as admin automatically.
-- @param player_name The player's Name#0000.
-- @return true/false (can become admin), reason
-- @private
function pshy.perms_CanAutoAdmin(player_name)
	if pshy.admins[player_name] then
		return false, "Already Admin"
	elseif player_name == pshy.loader then
		return true, "Script Loader"
	elseif pshy.perms_auto_admin_admins and string.sub(player_name, -5) == "#0001" then
		return true, "Admin &lt;3"
	elseif pshy.perms_auto_admin_moderators and string.sub(player_name, -5) == "#0010" then
		return true, "Moderator"
	elseif pshy.perms_auto_admin_funcorps and pshy.funcorps[player_name] then
		return true, "FunCorp"
	elseif pshy.perms_auto_admin_authors and pshy.authors[player_name] then
		return true, "Author"
	else
		return false, "Not Allowed"
	end
end
--- Check if a player use `!adminme` and notify them if so.
-- @private
-- @param player_name The player's Name#0000.
function pshy.perms_TouchPlayer(player_name)
	local can_admin, reason = pshy.perms_CanAutoAdmin(player_name)
	if can_admin then
		tfm.exec.chatMessage("<r>[PshyPerms]</r> <j>You may set yourself as a room admin (" .. reason .. ").</j>", player_name)
		for instruction in ipairs(pshy.admin_instructions) do
			tfm.exec.chatMessage("<r>[PshyPerms]</r> <fc>" .. instruction .. "</fc>", player_name)
		end
		tfm.exec.chatMessage("<r>[PshyPerms]</r> <j>To become a room admin, use `<fc>!adminme</fc>`</j>", player_name)
		print("[PshyPerms] " .. player_name .. " can join room admins.")
	end
end
--- TFM event eventNewPlayer.
function eventNewPlayer(player_name)
	pshy.perms_TouchPlayer(player_name)
end
--- !admin <NewAdmin#0000>
-- Add an admin in the pshy.admins set.
function pshy.perms_ChatCommandAdmin(user, new_admin_name)
	pshy.admins[new_admin_name] = true
	for admin_name, void in pairs(pshy.admins) do
		tfm.exec.chatMessage("<r>[PshyPerms]</r> " .. user .. " added " .. new_admin_name .. " as room admin.", admin_name)
	end
end
pshy.commands["admin"] = {func = pshy.perms_ChatCommandAdmin, desc = "add a room admin", argc_min = 1, argc_max = 1, arg_types = {"string"}, arg_names = {"Newadmin#0000"}}
pshy.help_pages["pshy_perms"].commands["admin"] = pshy.commands["admin"]
--- !unadmin <NewAdmin#0000>
-- Remove an admin from the pshy.admins set.
function pshy.perms_ChatCommandUnadmin(user, admin_name)
	pshy.admins[admin_name] = nil
	for admin_name, void in pairs(pshy.admins) do
		tfm.exec.chatMessage("<r>[PshyPerms]</r> " .. user .. " removed " .. admin_name .. " from room admins.", admin_name)
	end
end
pshy.commands["unadmin"] = {func = pshy.perms_ChatCommandUnadmin, desc = "remove a room admin", argc_min = 1, argc_max = 1, arg_types = {"string"}, arg_names = {"Newadmin#0000"}}
pshy.help_pages["pshy_perms"].commands["unadmin"] = pshy.commands["unadmin"]
--- !adminme
-- Add yourself as an admin if allowed by the module configuration.
function pshy.perms_ChatCommandAdminme(user)
	local allowed, reason = pshy.perms_CanAutoAdmin(user)
	if allowed then
		pshy.perms_AddAdmin(user, reason)
		return true
	else
		return false, reason
	end
end
pshy.commands["adminme"] = {func = pshy.perms_ChatCommandAdminme, desc = "join room admins if allowed", argc_min = 0, argc_max = 0}
pshy.help_pages["pshy_perms"].commands["adminme"] = pshy.commands["adminme"]
pshy.perms.everyone["!adminme"] = true
--- !admins
-- Add yourself as an admin if allowed by the module configuration.
function pshy.perms_ChatCommandAdmins(user)
	local strlist = ""
	for an_admin, is_admin in pairs(pshy.admins) do
		if is_admin then
			if #strlist > 0 then
				strlist = strlist .. ", "
			end
			strlist = strlist .. an_admin
		end
	end
	tfm.exec.chatMessage("<r>[PshyPerms]</r> Script Loader: " .. tostring(pshy.loader), user)
	tfm.exec.chatMessage("<r>[PshyPerms]</r> Room admins: " .. strlist .. ".", user)
	return true
end
pshy.commands["admins"] = {func = pshy.perms_ChatCommandAdmins, desc = "see a list of room admins", argc_min = 0, argc_max = 0}
pshy.help_pages["pshy_perms"].commands["admins"] = pshy.commands["admins"]
pshy.perms.everyone["!admins"] = true
--- !enablecheats
-- Add yourself as an admin if allowed by the module configuration.
function pshy.perms_ChatCommandEnablecheats(user, cheats_enabled)
	pshy.perms_cheats_enabled = cheats_enabled
	if cheats_enabled then
		return true, "cheat commands enabled for everyone"
	else
		return true, "cheat commands enabled for admins only"
	end
end
pshy.commands["enablecheats"] = {func = pshy.perms_ChatCommandEnablecheats, desc = "enable cheats commands for everyone", argc_min = 1, argc_max = 1, arg_types = {'boolean'}}
pshy.help_pages["pshy_perms"].commands["enablecheats"] = pshy.commands["enablecheats"]
pshy.perms.admins["!enablecheats"] = true
--- Pshy event eventInit.
function eventInit()
	for player_name in pairs(tfm.get.room.playerList) do
		pshy.perms_TouchPlayer(player_name)
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_utils_tfm.lua")
function new_mod.Content()
--- pshy_utils_tfm.lua
--
-- Basic functions related to TFM.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require pshy_perms.lua
-- @require pshy_utils_lua.lua
--
-- @hardmerge
pshy = pshy or {}
--- Get the display nick of a player.
-- @param player_name The player name.
-- @return either the part of the name before '#' or an entry from `pshy.nicks`.
function pshy.GetPlayerNick(player_name)
	-- disabled this logick because the pshy_nicks module isnt used anymore
	--if pshy.nicks and pshy.nicks[player_name] then
	--	return pshy.nicks[player_name]
	--else
		return pshy.StrSplit(player_name, "#", 2)[1]
	--end
end
--- Find a player's full Name#0000.
-- @param partial_name The beginning of the player name.
-- @return The player full name or (nil, reason).
-- @todo Search in nicks as well.
function pshy.FindPlayerName(partial_name)
	local player_list = tfm.get.room.playerList
	if player_list[partial_name] then
		return partial_name
	else
		local real_name
		for player_name in pairs(player_list) do
			if string.sub(player_name, 1, #partial_name) == partial_name then
				if real_name then
					return nil, "several players found" -- 2 players have this name
				end
				real_name = player_name
			end
		end
		if pshy.nicks then
			for player_name, nick in pairs(pshy.nicks) do
				if string.sub(nick, 1, #partial_name) == partial_name then
					if real_name then
						return nil, "several players found" -- 2 players have this name
					end
					real_name = player_name
				end
			end
		end
		if not real_name then
			return nil, "player not found"
		end
		return real_name -- found
	end
end
--- Find a player's full Name#0000 or throw an error.
-- @return The player full Name#0000 (or throw an error).
function pshy.FindPlayerNameOrError(partial_name)
	local real_name, reason = pshy.FindPlayerName(partial_name)
	if not real_name then
		error(reason)
	end
	return real_name
end
--- Convert a tfm enum index to an interger, searching in all tfm enums.
-- Search in bonus, emote, ground, particle and shamanObject.
-- @param index a string, either representing a tfm enum value or integer.
-- @return the existing enum value or nil
function pshy.TFMEnumGet(index)
	assert(type(index) == "string")
	local value
	for enum_name, enum in pairs(tfm.enum) do
		value = enum[index]
		if value then
			return value
		end
	end
	return nil
end
--- Get how many players are alive in tfm.get
function pshy.CountPlayersAlive()
	local count = 0
	for player_name, player in pairs(tfm.get.room.playerList) do
		if not player.isDead then
			count = count + 1
		end
	end
	return count
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_dialog.lua")
function new_mod.Content()
--- pshy_dialog.lua
--
-- Abstraction to show dialogs to a player, using a callback.
-- See pshy.dialog_Ask* functions.
-- The callbacks are called as `callback(player_name, answer)`.
--
-- @author TFM:Pshy#3752 DC:7998
--
-- @require pshy_merge.lua
-- @require pshy_print.lua
--
-- @require_priority UTILS
pshy = pshy or {}
--- Module Settings:
pshy.dialog_arbitrary_popup_id = 8
pshy.dialog_arbitrary_color_picker_id = 8
pshy.dialog_x = 300
pshy.dialog_y = 100
--- Internal use:
pshy.dialog_players_callbacks = {}
--- Open a boolean dialog.
-- @param player_name The player's Name#0000.
-- @param text Text to display in the popup.
-- @param callback A function ton call when the player have answered.
-- @cf pshy.dialog_SetPlayerCallback
function pshy.dialog_AskForYesOrNo(player_name, text, callback)
	pshy.dialog_players_callbacks[player_name] = callback
	ui.addPopup(pshy.dialog_arbitrary_popup_id, 1, text, player_name, pshy.dialog_x, pshy.dialog_y, nil, true)
end
--- Open a text dialog.
-- @param player_name The player's Name#0000.
-- @param text Text to display in the popup.
-- @param callback A function ton call when the player have answered.
-- @cf pshy.dialog_SetPlayerCallback
function pshy.dialog_AskForText(player_name, text, callback)
	pshy.dialog_players_callbacks[player_name] = callback
	ui.addPopup(pshy.dialog_arbitrary_popup_id, 2, text, player_name, pshy.dialog_x, pshy.dialog_y, nil, true)
end
--- Open a color dialog.
-- @param player_name The player's Name#0000.
-- @param title Text to display in the popup.
-- @param callback A function ton call when the player have answered.
-- @cf pshy.dialog_SetPlayerCallback
function pshy.dialog_AskForColor(player_name, title, callback, default_color)
	pshy.dialog_players_callbacks[player_name] = callback
	ui.showColorPicker(pshy.dialog_arbitrary_color_picker_id, player_name, default_color or 0xffffff, title)
end
--- Called when a player answered a question.
-- @private
-- @param player_name The player's Name#0000.
local function Answered(player_name, answer)
	local callback = pshy.dialog_players_callbacks[player_name]
	if callback then
		pshy.dialog_players_callbacks[player_name] = nil
		callback(player_name, answer)
	else
		print_warn("pshy_dialog: no callback for %s: %s", player_name, tostring(answer))
	end
end
--- TFM event eventPopupAnswer.
function eventPopupAnswer(popup_id, player_name, answer)
	if popup_id == pshy.dialog_arbitrary_popup_id then
		Answered(player_name, answer)
	end
end
--- TFM event eventColorPicked.
function eventColorPicked(popup_id, player_name, color)
	if popup_id == pshy.dialog_arbitrary_color_picker_id then
		Answered(player_name, color)
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_commands.lua")
function new_mod.Content()
--- pshy_commands.lua
--
-- This module can be used to implement in-game commands.
--
-- Example adding a command 'demo':
--   function my.function.demo(user, arg_int, arg_str)
--       print("hello " .. user .. "! " .. tostring(arg_int) .. tostring(arg_str))
--   end
--   pshy.commands["demo"] = {func = my.function.demo}			-- the function to call
--   pshy.commands["demo"].desc = "my demo function"			-- short description
--   pshy.commands["demo"].no_user = false						-- true to not pass the command user as the 1st arg
--   pshy.commands["demo"].argc_min = 1							-- need at least 1 arg
--   pshy.commands["demo"].argc_max = 2							-- max args (remaining args will be considered a single one)
--   pshy.commands["demo"].arg_types = {"number", "string"}		-- argument type as a string, nil for auto, a table to use as an enum, or a function to use for the conversion
--   pshy.commands["demo"].arg_names = {"index", "message"}		-- argument names
--   pshy.commands_aliases["ddeemmoo"] = "demo"					-- create an alias
--   pshy.perms.everyone["demo"] = true							-- everyone can run the command
--   pshy.perms.cheats["demo"] = true							-- everyone can run the command when cheats are enabled (useless in this example)
--   pshy.perms.admins["demo"] = true							-- admins can run the command (useless in this example)
--
-- This submodule add the folowing commands:
--   !help [command]				- show general or command help
--
-- @author DC: Pshy#7998
--
-- @require pshy_dialog.lua
-- @require pshy_utils_lua.lua
-- @require pshy_utils_tfm.lua
-- @require pshy_merge.lua
-- @require pshy_perms.lua
--
-- @require_priority UTILS
pshy = pshy or {}
--- Module Settings:
pshy.commands_require_prefix = false		-- if true, all commands must start with `!pshy.`
pshy.commands_always_enable_ui = true
--- Chat commands lists
-- keys represent the lowecase command name.
-- values are tables with the folowing fields:
-- - func: the function to run
--   the functions will take the player name as the first argument,
--   then the remaining ones.
-- - help: the help string to display when querying for help.
-- - arg_types: an array the argument types (not including the player name).
--   if arg_types is undefined then this is determined automatically.
-- - arg_names:
-- - no_user: true if the called function doesnt take the command user as
--   a first argument.
pshy.commands = pshy.commands or {}
pshy.commands_names_ordered = {}
--- Map of command aliases (string -> string)
pshy.commands_aliases = pshy.commands_aliases or {}
--- Get a command target player or throw on permission issue.
-- This function can be used to check if a player can run a command on another one.
-- @private
function pshy.commands_GetTargetOrError(user, target, perm_prefix)
	if not target then
		return user
	end
	if target == user then
		return user
	elseif not pshy.HavePerm(user, perm_prefix .. "-others") then
		error("You do not have permission to use this command on others.")
		return
	end
	return target
end
--- Get the real command name
-- @param alias_name Command name or alias without `!`.
local function ResolveAlias(alias_name)
	while not pshy.commands[alias_name] and pshy.commands_aliases[alias_name] do
		alias_name = pshy.commands_aliases[alias_name]
	end
	return alias_name
end
--- Get a chat command by name
-- @param alias_name Can be the command name or an alias, without `!`.
local function GetCommand(alias_name)
	return (pshy.commands[ResolveAlias(alias_name)])
end
--- Alias for GetCommand
-- @deprecated
pshy.GetChatCommand = GetCommand
--- Get html things to add before and after a command to display it with the right color.
function pshy.commands_GetPermColorMarkups(perm)
	if pshy.perms.everyone[perm] then
		return "<v>", "</v>"
	elseif pshy.perms.cheats[perm] then
		return "<j>", "</j>"
	elseif pshy.perms.admins[perm] then
		return "<r>", "</r>"
	else
		return "<vi>", "</vi>"
	end
end
--- Get a command usage.
-- The returned string represent how to use the command.
-- @param cmd_name The name of the command.
-- @return HTML text for the command's usage.
function pshy.commands_GetUsage(cmd_name)
	local text = "!" .. cmd_name
	local real_command = GetCommand(cmd_name)
	local min = real_command.argc_min or 0
	local max = real_command.argc_max or min
	if max > 0 then
		for i = 1, max do
			text = text .. " " .. ((i <= min) and "&lt;" or "[")
			if real_command.arg_names and i <= #real_command.arg_names then
				text = text .. real_command.arg_names[i]
			elseif real_command.arg_types and i <= #real_command.arg_types then
				if type(real_command.arg_types[i]) == "string" then
					text = text .. real_command.arg_types[i]
				else
					text = text .. type(real_command.arg_types[i])
				end
			else
				text = text .. "?"
			end
			text = text .. ((i <= min) and "&gt;" or "]")
		end
	end
	if not real_command.argc_max then
		text = text .. " [...]"
	end
	return text
end
--- Convert string arguments of a table to the specified types,
-- or attempt to guess the types.
-- @param args Table of elements to convert.
-- @param types Table of types.
-- @return true or (false, reason)
local function ConvertArgs(args, types)
	local reason
	local has_multiple_players = false
	for index = 1, #args do
		if (not types) or index > #types or types[index] == nil then
			-- automatic conversion
			args[index] = pshy.AutoType(args[index])
		elseif type(types[index]) == "function" then
			-- a function is used for conversion
			args[index], reason = types[index](args[index])
			if args[index] == nil then
				return false, (reason or ("wrong type for argument " .. tostring(index) .. ", conversion function returned `nil`"))
			end
		elseif type(types[index]) == "table" then
			-- a function is used as an enum
			args[index] = types[index][args[index]]
			if args[index] == nil then
				return false, "wrong type for argument " .. tostring(index) .. ", expected an enum value"
			end
		elseif types[index] == 'player' and args[index] == '*' then
			if has_multiple_players then
				return false, "only a single '*' argument may represent all the players"
			end
			has_multiple_players = true
		else
			-- using pshy.ToType with the given type string
			args[index], reason = pshy.ToType(args[index], types[index])
			if reason ~= nil then
				return false, reason
			end
			if args[index] == nil then
				return false, "wrong type for argument " .. tostring(index) .. ", expected " .. types[index]
			end
		end
	end
	return true
end
local players_resumable_commands = {}
local function AnsweredArg(user, answer)
	local resumable_command = players_resumable_commands[user]
	if not resumable_command then
		print_warn("pshy_commands: no command to resume for %s", user)
		return
	end
	local arg_type = "string"
	if resumable_command.command.arg_types then
		arg_type = resumable_command.command.arg_types[#resumable_command.argv + 1] or "string"
	end
	if arg_type == "color" and type(answer) == "number" then
		answer = string.format("#%06x", answer)
	end
	print_debug("chosen answer: %s", answer)
	table.insert(resumable_command.argv, tostring(answer))
	local command = resumable_command.command
	local argv = resumable_command.argv
	players_resumable_commands[user] = nil
	pshy.commands_RunCommandWithArgs(user, command, argv)
end
--- Ask the player for a missing information.
local function AskNextArg(user, command, argv)
	local arg_type = "string"
	local arg_index = #argv + 1
	if command.arg_types then
		arg_type = command.arg_types[#argv + 1] or "string"
	end
	local arg_name = nil
	if command.arg_names and command.arg_names[arg_index] then
		arg_name = command.arg_names[arg_index]
	end
	local text
	if arg_name then
		text = string.format("<n><b>%s</b></n> (argument %d):", arg_name, arg_index)
	else
		text = string.format("<n><b>%s</b></n> (argument %d):", arg_type, arg_index)
	end
	players_resumable_commands[user] = {command = command, argv = argv}
	if arg_type == "bool" or arg_type == "boolean" then
		pshy.dialog_AskForYesOrNo(user, text, AnsweredArg)
	elseif arg_type == "color" then
		pshy.dialog_AskForColor(user, (arg_type or arg_name or "anything"), AnsweredArg)
	else
		pshy.dialog_AskForText(user, text, AnsweredArg)
	end
end
--- Answer a player's command.
-- @param msg The message to send.
-- @param player_name The player who will receive the message.
local function Answer(msg, player_name)
	assert(player_name ~= nil)
	tfm.exec.chatMessage("<n>  " .. tostring(msg), player_name)
end
--- Answer a player's command (on error).
-- @param msg The message to send.
-- @param player_name The player who will receive the message.
local function AnswerError(msg, player_name)
	assert(player_name ~= nil)
	tfm.exec.chatMessage("<r>  " .. tostring(msg), player_name)
end
--- Run a command as a player.
-- @param user The Name#0000 of the player running the command.
-- @param command_str The full command the player have input, without "!".
-- @return false on permission failure, true if handled and not to handle, nil otherwise
function pshy.commands_Run(user, command_str)
	-- input asserts
	assert(type(user) == "string")
	assert(type(command_str) == "string")
	-- log commands used by non-admin players
	if not pshy.admins[user] then
		print("<g>[" .. user .. "] !" .. command_str)
	end
	-- ignore 'other.' commands
	if string.sub(command_str, 1, 6) == "other." then
		return
	end
	-- remove 'pshy.' prefix
	local had_pshy_prefix = false
	if string.sub(command_str, 1, 5) == "pshy." then
		command_str = string.sub(command_str, 6, #command_str)
		had_pshy_prefix = true
	elseif pshy.commands_require_prefix then
		return
	end
	-- get the command alias (command name) and the argument string
	local command_alias_and_args_str = pshy.StrSplit(command_str, " ", 2)
	local command_alias = command_alias_and_args_str[1]
	local args_str = command_alias_and_args_str[2]
	local command = GetCommand(command_alias)
	-- non-existing command
	if not command then
		if had_pshy_prefix then
			AnswerError("Unknown pshy command.", user)
			return nil
		end
		tfm.exec.chatMessage("Another module may handle this command.", user)
		return nil
	end
	-- check permissions
	if not pshy.HavePerm(user, "!" .. command.name) then
		AnswerError("You do not have permission to use this command.", user)
		return false
	end
	-- get args
	args = args_str and pshy.StrSplit(args_str, " ", command.argc_max or 32) or {} -- max command args set to 32 to prevent abuse
	return pshy.commands_RunCommandWithArgs(user, command, args)
end
--- Run a command (from a command table) with given args.
-- @param user Name#0000 of the user to run the command as.
-- @param command The command table representing the command to run.
-- @param argv List of arguments (strings).
-- @return false on permission failure, true if handled and not to handle, nil otherwise
function pshy.commands_RunCommandWithArgs(user, command, argv)
	-- check permissions
	if not pshy.HavePerm(user, "!" .. command.name) then
		AnswerError("You do not longer have permission to use this command.", user)
		return false
	end
	-- missing arguments
	if command.argc_min and #argv < command.argc_min then
		if command.ui or pshy.commands_always_enable_ui then
			AskNextArg(user, command, argv)
			return true
		end
		AnswerError("Usage: " .. pshy.commands_GetUsage(final_command_name), user)
		return false
	end
	-- too many arguments
	if command.argc_max and #argv > command.argc_max then
		AnswerError("This command do not use arguments.", user)
		return false
	end
	-- multiple players args
	local multiple_players_index = nil
	if command.arg_types then
		for i_type, type in ipairs(command.arg_types) do
			if type == "player" and argv[i_type] == '*' then
				multiple_players_index = i_type
			end
		end
	end
	-- convert arguments
	local rst, rtn = ConvertArgs(argv, command.arg_types)
	if not rst then
		AnswerError(tostring(rtn), user)
		return not had_prefix
	end
	-- runing the command
	local pcallrst, rst, rtn
	if multiple_players_index then
		-- command affect all players
		for player_name in pairs(tfm.get.room.playerList) do
			argv[multiple_players_index] = player_name
			if not command.no_user then
				pcallrst, rst, rtn = pcall(command.func, user, table.unpack(argv))
			else
				pcallrst, rst, rtn = pcall(command.func, table.unpack(argv))
			end
			if pcallrst == false or rst == false then
				break
			end
		end
	else
		-- command affect at most 1 player
		if not command.no_user then
			pcallrst, rst, rtn = pcall(command.func, user, table.unpack(argv))
		else
			pcallrst, rst, rtn = pcall(command.func, table.unpack(argv))
		end
	end
	-- display command results
	if pcallrst == false then
		-- pcall failed
		AnswerError(rst, user)
	elseif rst == false then
		-- command function returned false
		AnswerError(rtn, user)
	elseif rst == nil then
		-- command function returned false
		Answer("Command executed.", user)
	elseif rst == true and rtn ~= nil then
		-- command function returned true
		if type(rtn) == "string" then
			Answer(rtn, user)
		else
			Answer(string.format("Command returned %s.", tostring(rtn)), user)
		end
	end
end
--- !commands(cmds,help) []
-- List commands.
local function ChatCommandCommands(user, page_index)
	page_index = page_index or 1
	local commands_per_page = 10
	tfm.exec.chatMessage(string.format("<n>Commands (page %d/%d):</n>", page_index, #pshy.commands_names_ordered / commands_per_page), user)
	local i_command_first = ((page_index - 1) * commands_per_page) + 1
	local i_command_last = ((page_index - 1) * commands_per_page + 10)
	for i_command = i_command_first, i_command_last do
		local command_name = pshy.commands_names_ordered[i_command]
		if command_name then
			local usage = pshy.commands_GetUsage(command_name)
			local markup_1, markup_2 = pshy.commands_GetPermColorMarkups("!" .. command_name)
			tfm.exec.chatMessage(string.format("  %s%s%s", markup_1, usage, markup_2), user)
		else
			break
		end
	end
	return true
end
pshy.commands["commands"] = {func = ChatCommandCommands, desc = "list commands", argc_min = 0, argc_max = 1, arg_types = {"number"}}
pshy.perms.everyone["!commands"] = true
pshy.commands_aliases["cmds"] = "commands"
function eventChatCommand(player_name, message)
	return pshy.commands_Run(player_name, message)
end
function eventInit()
	-- complete command tables with the command name
	for command_name, command in pairs(pshy.commands) do
		command.name = command_name
		table.insert(pshy.commands_names_ordered, command_name)
	end
	table.sort(pshy.commands_names_ordered)
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_alternatives.lua")
function new_mod.Content()
--- pshy_alternatives.lua
--
-- Allow some scripts using restricted lua features to still work when those are not available.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
-- @require pshy_commands.lua
-- @require pshy_print.lua
--
-- @require_priority WRAPPER
pshy = pshy or {}
--- Help page:
pshy.help_pages = pshy.help_pages or {}				-- touching the help_pages table
pshy.help_pages["pshy_alternatives"] = {title = "LUA Features Alternatives", text = "Allow some scripts to run without all lua features.\n", commands = {}}
--- Module Settings:
pshy.alternatives_chat_arbitrary_id = 84
local have_sync_access = (tfm.exec.getPlayerSync() ~= nil)		-- currently defined in `pshy_perms.lua`, true when funcorp features are available
--- Internal Use:
pshy.commands = pshy.commands or {}						-- touching the commands table
pshy.alternatives_chatMessage = tfm.exec.chatMessage		-- original chatMessage function
pshy.alternatives_players_chats = {}						-- stores the last messages sent per player with nofuncorp_chatMessage
pshy.alternatives_players_hidden_chats = {}				-- status of chats
pshy.alternatives_last_loop_time = 0						-- replacement for game timers
pshy.alternatives_timers = {}								-- replacement for game timers
--- Get a nofuncorp player's chat content.
function pshy.alternatives_GetPlayerChatContent(player_name)
	local chat = pshy.alternatives_players_chats[player_name]
	local total = ""
	for i_line, line in ipairs(chat) do
		total = "<n>" .. total .. line .. "</n>\n"
	end
	return total
end
--- Update a nofuncorp player's chat.
function pshy.alternatives_UpdatePlayerChat(player_name)
	if not pshy.alternatives_players_hidden_chats[player_name] then
		local text = pshy.alternatives_GetPlayerChatContent(player_name)
		ui.addTextArea(pshy.alternatives_chat_arbitrary_id, text, player_name, 0, 50, 400, nil, 0x0, 0x0, 1.0, true)
	else
		ui.removeTextArea(pshy.alternatives_chat_arbitrary_id, player_name)
	end
end
--- Replacement for `tfm.exec.chatMessage`.
-- @TODO: only remove older chat messages if required.
function pshy.alternatives_chatMessage(message, player_name)
	-- convert message
	if type(message) ~= "string" then
		message = tostring(message)
	end
	-- params checks
	if #message > 200 then
		print_error("<fc>[Alt]</fc> chatMessage: message length is limited to 200!")
		return
	end
	-- nil player value
	if not player_name then
		for player_name in pairs(tfm.get.room.playerList) do
			pshy.alternatives_chatMessage(message, player_name)
		end
		return
	end
	-- add message
	pshy.alternatives_players_chats[player_name] = pshy.alternatives_players_chats[player_name] or {}
	local chat = pshy.alternatives_players_chats[player_name]
	if #chat > 8 then
		table.remove(chat, 1)
	end
	table.insert(chat, message)
	-- display
	pshy.alternatives_UpdatePlayerChat(player_name)
end
--- Replacement for `system.addTimer`.
-- @todo Test this.
function pshy.alternatives_newTimer(callback, time, loop, arg1, arg2, arg3, arg4)
	-- params checks
	if time < 1000 then
		print_error("<fc>[Alt]</fc> newTimer: minimum time is 1000!")
		return
	end
	-- find an id
	local timer_id = 1
	while pshy.alternatives_timers[timer_id] do
		timer_id = timer_id + 1
	end
	-- create
	pshy.alternatives_timers[timer_id] = {}
	timer = pshy.alternatives_timers[timer_id]
	timer.timer_id = timer_id
	timer.callback = callback
	timer.time = time
	timer.loop = loop
	timer.arg1 = arg1
	timer.arg2 = arg2
	timer.arg3 = arg3
	timer.arg4 = arg4
	timer.next_run_time = 0 + timer.time
	return timer_id
end
--- Replacement for `system.removeTimer`.
function pshy.alternatives_removeTimer(timer_id)
	pshy.nofuncorm_timers[timer_id] = nil
end
--- Replacement for `tfm.exec.getPlayerSync`.
-- Yes, the return is wrong, the goal is only to let modules work without spamming the log.
function pshy.alternatives_getPlayerSync()
	return pshy.loader
end
--- TFM event eventNewGame
function eventNewGame()
	if not have_sync_access then
		for i_timer,timer in pairs(pshy.alternatives_timers) do
			timer.next_run_time = timer.next_run_time - pshy.alternatives_last_loop_time
		end
		pshy.alternatives_last_loop_time = 0
	end
end
--- TFM event eventLoop.
function eventLoop(time, time_remaining)
	if not have_sync_access then
		pshy.alternatives_last_loop_time = time
		local ended_timers = {}
		for i_timer, timer in pairs(pshy.alternatives_timers) do
			if timer.next_run_time < time then
				timer.callback(timer.timer_id, timer.arg1, timer.arg2, timer.arg3, timer.arg4)
				if timer.loop then
					timer.next_run_time = timer.next_run_time + timer.time
				else
					ended_timers[i_timer] = true
				end
			end
		end
		for i_ended_timer in pairs(ended_timers) do
			pshy.alternatives_timers[i_ended_timer] = nil
		end
	end
end
--- !chat
local function ChatCommandChat(user)
	pshy.alternatives_players_hidden_chats[user] = not pshy.alternatives_players_hidden_chats[user]
	pshy.alternatives_UpdatePlayerChat(user)
	return true
end
pshy.commands["chat"] = {func = ChatCommandChat, desc = "toggle the alternative chat", argc_min = 0, argc_max = 0}
pshy.help_pages["pshy_alternatives"].commands["chat"] = pshy.commands["chat"]
pshy.perms.everyone["!chat"] = true
--- Initialization:
function eventInit()
	if not have_sync_access then
		tfm.exec.chatMessage = pshy.alternatives_chatMessage
		system.newTimer = pshy.alternatives_newTimer
		system.removeTimer = pshy.alternatives_removeTimer
		tfm.exec.removeTimer = pshy.alternatives_removeTimer
		tfm.exec.getPlayerSync = pshy.alternatives_getPlayerSync
		tfm.exec.chatMessage("This text area is replacing tfm.exec.chatMessage().")
		tfm.exec.chatMessage("Type <ch2>!chat</ch2> to toggle this text.")
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_ui.lua")
function new_mod.Content()
--- pshy_ui.lua
--
-- Module simplifying ui creation.
-- Every ui is represented by a pshy ui table storing its informations.
--
-- @author Pshy
-- @namespace pshy
-- @require pshy_commands.lua
-- @require pshy_utils_lua.lua
--
-- @require_priority UTILS
pshy = pshy or {}
-- ui.addTextArea (id, text, targetPlayer, x, y, width, height, backgroundColor, borderColor, backgroundAlpha, fixedPos)
-- ui.updateTextArea (id, text, targetPlayer)
-- ui.removeTextArea (id, targetPlayer)
--
-- ui.addPopup (id, type, text, targetPlayer, x, y, width, fixedPos)
-- ui.showColorPicker (id, targetPlayer, defaultColor, title)
--
-- <p align='center'><font color='#badb2f' size='24' face='Soopafresh'>Help</font></p><br>hejsfsejh<u></u><i></i><b></b>
--- Create a pshy ui
function pshy.UICreate(text)
	local ui = {}
	ui.id = 2049
	ui.text = text or "<b>New Control</b>"
	ui.player = nil
	ui.x = 50
	ui.y = 50
	ui.w = nil --700
	ui.h = nil --500
	--ui.back_color = 0x010101
	--ui.border_color = 0xffff00
	ui.alpha = 1.0
	ui.fixed = true
	return ui
end
--- Show a pshy ui
function pshy.UIShow(u, player_name)
	ui.addTextArea(u.id, u.text, player_name or u.player, u.x, u.y, u.w, u.h, u.back_color, u.border_color, u.alpha, u.fixed)
end
--- TFM text area click
-- events are separated by a '\n', so a single click can trigger several events.
-- events close, closeall, pcmd and cmd are hardcoded
function eventTextAreaCallback(textAreaId, playerName, callback)
	if type(callback) ~= "string" then
		print(string.format("WARNING: eventTextAreaCallback callback was %s", type(callback)))
		return
	end
	callbacks = pshy.StrSplit(callback, "\n")
	for i_c, c in ipairs(callbacks) do
		-- close callback
		if (c == "close") then
			ui.removeTextArea(textAreaId, playerName)
		end
		-- closeall callback
		if (c == "closeall") then
			if pshy.admins[playerName] then
				ui.removeTextArea(textAreaId, nil)
			end
		end
		-- pcmd callback
		if (string.sub(c, 1, 5) == "pcmd ") then
			pshy.commands_Run(playerName, pshy.StrSplit(c, " ", 2)[2])
		end
		-- apcmd callback
		if (string.sub(c, 1, 6) == "apcmd ") then
			if pshy.admins[playerName] then
				pshy.commands_Run(playerName, pshy.StrSplit(c, " ", 2)[2])
			else
				return
			end
		end
		-- cmd callback
		if (string.sub(c, 1, 4) == "cmd ") then
			eventChatCommand(playerName, pshy.StrSplit(c, " ", 2)[2])
			eventChatMessage(playerName, "!" .. pshy.StrSplit(c, " ", 2)[2])
		end
	end
end
--- TFM event eventChatMessage
-- This is just to touch the event so it exists.
function eventChatMessage(player_name, message)
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_players.lua")
function new_mod.Content()
--- pshy_players.lua
--
-- A global `pshy.players` table to store players informations.
-- Other modules may add their fields to a player's table, using that module's prefix.
--
-- Player fields provided by this module:
--	- `name`:					The Name#0000 of the player.
--	- `tfm_player`:				The corresponding table entry in `tfm.get.room.playerList`.
--	- `has_admin_tag`
--	- `has_moderator_tag`
--	- `has_sentinel_tag`
--	- `has_mapcrew_tag`
--	- `has_previous_staff_tag`
--	- `alive`					`true` if the player is alive.
--	- `won`						`true` if the player has entered the hole.
--	- `cheeses`					How many cheeses this player have.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require_priority UTILS
pshy = pshy or {}
--- Module settings and public members:
pshy.delete_players_on_leave = false			-- delete a player's table when they leave
pshy.players = {}								-- the global players table
--- Ensure a table entry exist in `pshy.players` for a player, creating it if required.
-- Also set the default fields in the table.
-- @private
-- @param player_name The Name#0000 if the player.
function pshy.players_Touch(player_name)
	if pshy.players[player_name] then
		return
	end
	local new_player = {}
	new_player.name = player_name
	new_player.tfm_player = tfm.get.room.playerList[player_name]
	new_player.has_admin_tag = (string.sub(player_name, -5) == "#0001")
	new_player.has_moderator_tag = (string.sub(player_name, -5) == "#0010")
	new_player.has_sentinel_tag = (string.sub(player_name, -5) == "#0015")
	new_player.has_mapcrew_tag = (string.sub(player_name, -5) == "#0020")
	new_player.has_previous_staff_tag = (string.sub(player_name, -5) == "#0095")
	new_player.alive = false
	new_player.won = false
	new_player.cheeses = 0
	pshy.players[player_name] = new_player
end
function eventNewPlayer(player_name)
	pshy.players_Touch(player_name)
end
function eventPlayerLeft(player_name)
    if pshy.delete_players_on_leave then
    	pshy.players[player_name] = nil
    end
	local player = pshy.players[player_name]
	player.alive = false
	player.cheeses = 0
end
function eventNewGame()
	for player_name in pairs(tfm.get.room.playerList) do
		local player = pshy.players[player_name]
		player.alive = true
		player.won = false
		player.cheeses = 0
	end
end
function eventPlayerWon(player_name)
	local player = pshy.players[player_name]
	player.alive = false
	player.won = true
	player.cheeses = 0
end
function eventPlayerDied(player_name)
	pshy.players[player_name].alive = false
end
function eventPlayerGetCheese(player_name)
	local player = pshy.players[player_name]
	player.cheeses = player.cheeses + 1
end
function eventPlayerRespawn(player_name)
	local player = pshy.players[player_name]
	player.alive = true
	if player.won then
		player.won = false
		player.cheeses = 0
	end
end
--- tfm.exec.giveCheese hook.
-- @TODO: test on multicheese maps.
local tfm_giveCheese = tfm.exec.giveCheese
tfm.exec.giveCheese = function(player_name)
	if pshy.players[player_name] then
		pshy.players[player_name].cheeses = 1
	end
	return tfm_giveCheese(player_name)
end
--- tfm.exec.removeCheese hook.
local tfm_removeCheese = tfm.exec.removeCheese
tfm.exec.removeCheese = function(player_name)
	if pshy.players[player_name] then
		pshy.players[player_name].cheeses = 0
	end
	return tfm_removeCheese(player_name)
end
--- tfm.exec.respawnPlayer hook.
local tfm_respawnPlayer = tfm.exec.respawnPlayer
tfm.exec.respawnPlayer = function(player_name)
	if pshy.players[player_name] then
		pshy.players[player_name].cheeses = 0
	end
	return tfm_respawnPlayer(player_name)
end
function eventInit()
	for player_name in pairs(tfm.get.room.playerList) do
		pshy.players_Touch(player_name)
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_players_keyboard.lua")
function new_mod.Content()
--- pshy_players_keyboard.lua
--
-- Extends `pshy.players` with features using the `eventKeyboard` event.
--
-- Adds the folowing fields:
-- - `is_facing_right`: Is the player facing right.
--
-- Adds the folowing events:
-- - `eventPlayerDirectionChanged(player_name, is_facing_right)`
-- - `eventPlayerJumpedKey(player_name)`
-- - `eventPlayerCrouchKey(player_name)`
-- - `eventPlayerMeepKey(player_name)`
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require pshy_players.lua
-- @require_priority WRAPPER
--- Internal Use:
local players = pshy.players			-- optimization
--- Tell the script that a player exist.
local function TouchPlayer(player_name)
	-- direction
	players[player_name].is_facing_right = true
	system.bindKeyboard(player_name, 0, true, true)
	system.bindKeyboard(player_name, 2, true, true)
end
function eventPlayerRespawn(player_name)
	-- direction
	players[player_name].is_facing_right = true
end
function eventKeyboard(player_name, keycode, down, x, y)
	local player = players[player_name]
	if down then
		-- direction
		if keycode == 0 then
			if player.is_facing_right ~= false then
				player.is_facing_right = false
				if eventPlayerDirectionChanged then
					eventPlayerDirectionChanged(player_name, false)
				end
			end
		elseif keycode == 2 then
			if player.is_facing_right ~= true then
				player.is_facing_right = true
				if eventPlayerDirectionChanged then
					eventPlayerDirectionChanged(player_name, true)
				end
			end
		-- eventPlayerjumpKey
		elseif keycode == 1 then
			if eventPlayerJumpedKey then
				eventPlayerJumpedKey(player_name)
			end
		-- eventPlayerCrouchKey
		elseif keycode == 3 then
			if eventPlayerCrouchKey then
				eventPlayerCrouchKey(player_name)
			end
		-- eventPlayerMeepKey
		elseif keycode == 32 then
			if eventPlayerMeepKey then
				eventPlayerMeepKey(player_name)
			end
		end
	end
end
function eventNewPlayer(player_name)
	TouchPlayer(player_name)
end
function eventNewGame()
	for player_name in pairs(tfm.get.room.playerList) do
		-- direction
		players[player_name].is_facing_right = true
	end
end
function eventInit()
	for player_name in pairs(tfm.get.room.playerList) do
		TouchPlayer(player_name)
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_help.lua")
function new_mod.Content()
--- pshy_help.lua
--
-- Add a help commands and in-game help functionalities.
--
-- @author tfm:Pshy#3752
--
-- @require pshy_commands.lua
-- @require pshy_ui.lua
--- Help pages.
-- Key is the name page.
-- Value is the help table (help page).
-- Help pages fields:
--	string:back		- upper page.
--	string:title		- title of the page.
--	string:text		- text to display at the top of the page.
--	set:commands		- set of chat command names.
--	set:examples		- map of action (string) -> command (string) (click to run).
--	set:subpages		- set of pages to be listed in that one at the bottom.
--	bool:restricted	- if true, require the permission "!help page_name"
pshy.help_pages = pshy.help_pages or {}
--- Main help page (`!help`).
-- This page describe the help available.
pshy.help_pages[""] = {title = "Main Help", text = "This page list the available help pages.\n", subpages = {}}
pshy.help_pages["pshy"] = {back = "", title = "Pshy Modules ", text = "Version '" .. tostring(__PSHY_VERSION__) .. "'. You may optionaly prefix pshy's commands by 'pshy '. Use * to run a command on every player.", subpages = {}}
pshy.help_pages[""].subpages["pshy"] = pshy.help_pages["pshy"]
--- Get a chat command desc text.
-- @param chat_command_name The name of the chat command.
function pshy.GetChatCommandDesc(chat_command_name)
	local cmd = pshy.commands[chat_command_name]
	local desc = cmd.desc or "no description"
	return desc
end
--- Get a chat command help html.
-- @param chat_command_name The name of the chat command.
function pshy.GetChatCommandHelpHtml(command_name)
	local real_command = pshy.GetChatCommand(command_name)
	local html = "<j><i><b>"
	-- usage
	local html = html .. pshy.commands_GetUsage(command_name)
	-- short description
	html = html .. "</b></i>\t - " .. (real_command.desc and tostring(real_command.desc) or "no description")
	-- help + other info
	if real_command.help then
		html = html .. "\n" .. real_command.help
	end
	if not real_command.func then
		html = html .. "\nThis command is not handled by pshy_commands."
	end
	html = html .. "</j>"
	return html
end
--- Get the html to display for a page.
function pshy.GetHelpPageHtml(page_name, is_admin)
	local page = pshy.help_pages[page_name]
	page = page or pshy.help_pages[""]
	local html = ""
	-- title menu
	local html = "<p align='right'>"
	html = html .. " <bl><a href='event:pcmd help " .. (page.back or "") .. "'>[  ]</a></bl>"
	html = html .. " <r><a href='event:close'>[  ]</a></r>"
	html = html .. "</p>"
	-- title
	html = html .. "<p align='center'><font size='16'>" .. (page.title or page_name) .. '</font></p>\n'
	-- restricted ?
	if page.restricted and not is_admin then
		html = html .. "<p align='center'><font color='#ff4444'>Access to this page is restricted.</font></p>\n"
		return html
	end
	-- text
	html = html .. "<p align='center'>" .. (page.text or "") .. "</p>"
	-- commands
	if page.commands then
		html = html .. "<bv><p align='center'><font size='16'>Commands" .. "</font></p>\n"
		for cmd_name, cmd in pairs(page.commands) do
			local m1, m2 = pshy.commands_GetPermColorMarkups("!" .. cmd_name)
			--html = html .. '!' .. ex_cmd .. "\t - " .. (cmd.desc or "no description") .. '\n'
			html = html .. m1
			--html = html .. "<u><a href='event:pcmd help " .. cmd_name .. "'>" .. pshy.commands_GetUsage(cmd_name) .. "</a></u>"
			html = html .. "<u>" .. pshy.commands_GetUsage(cmd_name) .. "</u>"
			html = html .. m2
			html = html .. "\t - " .. (cmd.desc or "no description") .. "\n"
		end
		html = html .. "</bv>\n"
	end
	-- examples
	if page.examples then
		html = html .. "<rose><p align='center'><font size='16'>Examples" .. "</font> (click to run)</p>\n"
		for ex_cmd, ex_desc in pairs(page.examples) do
			--html = html .. "!" .. ex_cmd .. "\t - " .. ex_desc .. '\n'
			html = html .. "<j><i><a href='event:cmd " .. ex_cmd .. "'>!" .. ex_cmd .. "</a></i></j>\t - " .. ex_desc .. '\n'
		end
		html = html .. "</rose>\n"
	end
	-- subpages
	if page.subpages then
		html = html .. "<ch><p align='center'><font size='16'>Subpages:" .. "</font></p>\n<p align='center'>"
		for subpage_name, subpage in pairs(page.subpages) do
			--html = html .. subpage .. '\n'
			if subpage and subpage.title then
				html = html .. "<u><a href='event:pcmd help " .. subpage_name .. "'>" .. subpage.title .. "</a></u>\n"
			else
				html = html .. "<u><a href='event:pcmd help " .. subpage_name .. "'>" .. subpage_name .. "</a></u>\n"
			end
		end
		html = html .. "</p></ch>"
	end
	return html
end
--- !help [command]
-- Get general help or help about a specific page/command.
local function ChatCommandMan(user, page_name)
	if page_name == nil then
		html = pshy.GetHelpPageHtml(nil)
	elseif string.sub(page_name, 1, 1) == '!' then
		html = pshy.GetChatCommandHelpHtml(string.sub(page_name, 2, #page_name))
		tfm.exec.chatMessage(html, user)
		return true
	elseif pshy.help_pages[page_name] then
		html = pshy.GetHelpPageHtml(page_name, pshy.HavePerm(user, "!help " .. page_name))
	elseif pshy.commands[page_name] then
		html = pshy.GetChatCommandHelpHtml(page_name)
		tfm.exec.chatMessage(html, user)
		return true
	else
		html = pshy.GetHelpPageHtml(page_name)
	end
	html = "<font size='10'><b><n>" .. html .. "</n></b></font>"
	if #html > 2000 then
		error("#html is too big: == " .. tostring(#html))
	end
	local ui = pshy.UICreate(html)
	ui.x = 100
	ui.y = 50
	ui.w = 600
	--ui.h = 440
	ui.back_color = 0x000000
	ui.border_color = 0xffffff
	ui.alpha = 0.9
	pshy.UIShow(ui, user)
	return true
end
pshy.commands["man"] = {func = ChatCommandMan, desc = "show a help panel", argc_min = 0, argc_max = 1, arg_types = {"string"}}
pshy.perms.everyone["!man"] = true
pshy.commands_aliases["help"] = "man"
--- Pshy event eventInit
function eventInit()
	-- other page
	pshy.help_pages["other"] = {title = "Other Pages", subpages = {}}
	for page_name, help_page in pairs(pshy.help_pages) do
		if not help_page.back then
			pshy.help_pages["other"].subpages[page_name] = help_page
		end
	end
	pshy.help_pages["pshy"].subpages["other"] = pshy.help_pages["other"]
	-- all page
	pshy.help_pages["all"] = {title = "All Pages", subpages = {}}
	for page_name, help_page in pairs(pshy.help_pages) do
		pshy.help_pages["all"].subpages[page_name] = help_page
	end
	pshy.help_pages["pshy"].subpages["all"] = pshy.help_pages["all"]
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_commands_fun.lua")
function new_mod.Content()
--- pshy_commands_fun.lua
--
-- Adds fun commands everyone can use.
-- Expected to be used in chill rooms, such as villages.
--
-- Disable cheat commands with `pshy.commands_fun_DisableCheatCommands()`.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require pshy_commands.lua
-- @require pshy_help.lua
-- @require pshy_perms.lua
--
-- @require_priority UTILS
--- Module Help Page:
pshy.help_pages["pshy_commands_fun"] = {back = "pshy", title = "Fun Commands", text = "Adds fun commands everyone can use.\n", commands = {}}
pshy.help_pages["pshy"].subpages["pshy_commands_fun"] = pshy.help_pages["pshy_commands_fun"]
--- Internal use:
local link_wishes = {}			-- map of player names requiring a link to another one
local players_balloon_id = {}
--- Get the target of the command, throwing on permission issue.
local GetTarget = pshy.commands_GetTargetOrError
--- !shaman
local function ChatCommandShaman(user, value, target)
	target = GetTarget(user, target, "!shaman")
	if value == nil then
		value = not tfm.get.room.playerList[target].isShaman
	end
	tfm.exec.setShaman(target, value)
	return true, string.format("%s %s", target, value and "is now a shaman." or "is no longer a shaman.")
end
pshy.commands["shaman"] = {func = ChatCommandShaman, desc = "switch you to a shaman", argc_min = 0, argc_max = 2, arg_types = {"bool", "player"}}
pshy.help_pages["pshy_commands_fun"].commands["shaman"] = pshy.commands["shaman"]
pshy.perms.admins["!shaman"] = true
pshy.perms.admins["!shaman-others"] = true
pshy.commands_aliases["sham"] = "shaman"
--- !shamanmode
local function ChatCommandShamanmode(user, mode, target)
	target = GetTarget(user, target, "!shamanmode")
	if mode ~= 0 and mode ~= 1 and mode ~= 2 then
		return false, "Mode must be 0 (normal), 1 (hard) or 2 (divine)."
	end
	tfm.exec.setShaman(target, value)
	return true, string.format("Set %s's shaman mode to %d.", target, mode)
end
pshy.commands["shamanmode"] = {func = ChatCommandShamanmode, desc = "choose your shaman mode (0/1/2)", argc_min = 0, argc_max = 2, arg_types = {"number", "player"}}
pshy.help_pages["pshy_commands_fun"].commands["shamanmode"] = pshy.commands["shamanmode"]
pshy.perms.admins["!shamanmode"] = true
pshy.perms.admins["!shamanmode-others"] = true
--- !vampire
local function ChatCommandVampire(user, value, target)
	target = GetTarget(user, target, "!vampire")
	if value == nil then
		value = not tfm.get.room.playerList[target].isVampire
	end
	tfm.exec.setVampirePlayer(target, value)
	return true, string.format("%s %s", target, value and "is now a vampire." or "is no longer a vampire.")
end
pshy.commands["vampire"] = {func = ChatCommandVampire, desc = "switch you to a vampire", argc_min = 0, argc_max = 2, arg_types = {"bool", "player"}}
pshy.help_pages["pshy_commands_fun"].commands["vampire"] = pshy.commands["vampire"]
pshy.perms.admins["!vampire"] = true
pshy.perms.admins["!vampire-others"] = true
--- !cheese
local function ChatCommandCheese(user, value, target)
	target = GetTarget(user, target, "!cheese")
	if value == nil then
		value = not tfm.get.room.playerList[target].hasCheese
	end
	if value then
		tfm.exec.giveCheese(target)
	else
		tfm.exec.removeCheese(target)
	end
	return true, string.format("%s %s", target, value and "now have the cheese." or "do no longer have the cheese.")
end
pshy.commands["cheese"] = {func = ChatCommandCheese, desc = "toggle your cheese", argc_min = 0, argc_max = 2, arg_types = {"bool", "player"}}
pshy.help_pages["pshy_commands_fun"].commands["cheese"] = pshy.commands["cheese"]
pshy.perms.cheats["!cheese"] = true
pshy.perms.admins["!cheese-others"] = true
--- !win
local function ChatCommandWin(user, target)
	target = GetTarget(user, target, "!win")
	tfm.exec.giveCheese(target)
	tfm.exec.playerVictory(target)
	return true, string.format("%s won.", target)
end
pshy.commands["win"] = {func = ChatCommandWin, desc = "play the win animation", argc_min = 0, argc_max = 1, arg_types = {"player"}}
pshy.help_pages["pshy_commands_fun"].commands["win"] = pshy.commands["win"]
pshy.perms.cheats["!win"] = true
pshy.perms.admins["!win-others"] = true
--- !kill
local function ChatCommandKill(user, target)
	target = GetTarget(user, target, "!kill")
	tfm.exec.killPlayer(target)
	return true, string.format("%s killed.", target)
end
pshy.commands["kill"] = {func = ChatCommandKill, desc = "kill yourself", argc_min = 0, argc_max = 1, arg_types = {"player"}}
pshy.help_pages["pshy_commands_fun"].commands["kill"] = pshy.commands["kill"]
pshy.perms.cheats["!kill"] = true
pshy.perms.admins["!kill-others"] = true
--- !respawn
local function ChatCommandRespawn(user, target)
	target = GetTarget(user, target, "!respawn")
	tfm.exec.respawnPlayer(target)
	return true, string.format("%s respawned.", target)
end
pshy.commands["respawn"] = {func = ChatCommandRespawn, desc = "resurect yourself", argc_min = 0, argc_max = 1, arg_types = {"player"}}
pshy.help_pages["pshy_commands_fun"].commands["respawn"] = pshy.commands["respawn"]
pshy.commands_aliases["resurect"] = "respawn"
pshy.perms.cheats["!respawn"] = true
pshy.perms.admins["!respawn-others"] = true
--- !freeze
local function ChatCommandFreeze(user, value, target)
	target = GetTarget(user, target, "!freeze")
	tfm.exec.freezePlayer(target, value)
	return true, string.format("%s %d", target, value and "frozen." or "no longer frozen.")
end
pshy.commands["freeze"] = {func = ChatCommandFreeze, desc = "freeze yourself", argc_min = 1, argc_max = 2, arg_types = {"bool", "player"}}
pshy.help_pages["pshy_commands_fun"].commands["freeze"] = pshy.commands["freeze"]
pshy.perms.cheats["!freeze"] = true
pshy.perms.admins["!freeze-others"] = true
--- !size <n>
local function ChatCommandSize(user, size, target)
	if size < 0.2 then
		return false, "The minimum size is `0.2`."
	end
	if size > 5 then
		return false, "The maximum size is `5`."
	end
	assert(size >= 0.2, "minimum size is 0.2")
	assert(size <= 5, "maximum size is 5")
	target = GetTarget(user, target, "!size")
	tfm.exec.changePlayerSize(target, size)
	return true, string.format("%s'size changed to %f.", target, size)
end
pshy.commands["size"] = {func = ChatCommandSize, desc = "change your size", argc_min = 1, argc_max = 2, arg_types = {"number", "player"}}
pshy.help_pages["pshy_commands_fun"].commands["size"] = pshy.commands["size"]
pshy.perms.cheats["!size"] = true
pshy.perms.admins["!size-others"] = true
--- !namecolor
local function ChatCommandNamecolor(user, color, target)
	target = GetTarget(user, target, "!namecolor")
	tfm.exec.setNameColor(target, color)
	return true, string.format("%s'name color is now <font color='#%06x'>#%06x</font>.", target, color, color)
end
pshy.commands["namecolor"] = {func = ChatCommandNamecolor, desc = "change your name's color", argc_min = 1, argc_max = 2, arg_types = {nil, "player"}}
pshy.help_pages["pshy_commands_fun"].commands["namecolor"] = pshy.commands["namecolor"]
pshy.perms.cheats["!namecolor"] = true
pshy.perms.admins["!namecolor-others"] = true
--- !balloon
local function ChatCommandBalloon(user, target)
	target = GetTarget(user, target, "!balloon")
	if players_balloon_id[target] then
		tfm.exec.removeObject(players_balloon_id[target])
		players_balloon_id[target] = nil
	end
	players_balloon_id[target] = tfm.exec.attachBalloon(target, true, math.random(1, 4), true)
	return true, string.format("Attached a balloon to %s.", target)
end
pshy.commands["balloon"] = {func = ChatCommandBalloon, desc = "attach a balloon to yourself", argc_min = 0, argc_max = 1, arg_types = {"player"}}
pshy.help_pages["pshy_commands_fun"].commands["balloon"] = pshy.commands["balloon"]
pshy.perms.cheats["!balloon"] = true
pshy.perms.admins["!balloon-others"] = true
--- !link
local function ChatCommandLink(user, wish, target)
	target = GetTarget(user, target, "!link")
	if wish == nil then
		tfm.exec.linkMice(target, target, false)
	else
		wish = pshy.FindPlayerNameOrError(wish)
		link_wishes[target] = wish
	end
	if wish == target then
		tfm.exec.linkMice(target, wish, false)
		return true, "Unlinked."
	elseif link_wishes[wish] == target or user ~= target then
		tfm.exec.linkMice(target, wish, true)
		return true, "Linked."
	end
end
pshy.commands["link"] = {func = ChatCommandLink, desc = "attach yourself to another player (yourself to stop)", argc_min = 1, argc_max = 2, arg_types = {"player", "player"}}
pshy.help_pages["pshy_commands_fun"].commands["link"] = pshy.commands["link"]
pshy.perms.cheats["!link"] = true
pshy.perms.admins["!link-others"] = true
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_essentials.lua")
function new_mod.Content()
--- pshy_essentials.lua
--
-- Useful optional modules.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
--
-- @require pshy_alternatives.lua
-- @require pshy_assert.lua
-- @require pshy_commands_fun.lua
--
-- @hardmerge
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_speedfly.lua")
function new_mod.Content()
--- pshy_speedfly.lua
--
-- Fly, speed boost, and teleport features.
--
-- @author DC:Pshy#7998 TFM:Pshy#3752
-- @namespace pshy
-- @require pshy_commands.lua
-- @require pshy_help.lua
--
-- @require_priority UTILS
--- Module Help Page:
pshy.help_pages["pshy_speedfly"] = {back = "pshy", title = "Speed / Fly / Teleport", text = "Fly and speed boost.\n", commands = {}}
pshy.help_pages["pshy"].subpages["pshy_speedfly"] = pshy.help_pages["pshy_speedfly"]
--- Settings:
pshy.speedfly_reset_on_new_game = true
--- Internal Use:
local flyers = {}		-- flying players
local speedies = {}		-- speedy players (value is the speed)
--- Give speed to a player.
function pshy.speedfly_Speed(player_name, speed)
	if speed == nil then
		speed = 20
	end
	if speed <= 1 or speed == false or speed == speedies[player_name]then
		speedies[player_name] = nil
		tfm.exec.chatMessage("<i><ch2>You are back to turtle speed.</ch2></i>", player_name)
	else
		speedies[player_name] = speed
		tfm.exec.bindKeyboard(player_name, 0, true, true)
		tfm.exec.bindKeyboard(player_name, 2, true, true)
		tfm.exec.chatMessage("<i><ch>You feel like sonic!</ch></i>", player_name)
	end
end
--- Give fly to a player.
function pshy.speedfly_Fly(player_name, value)
	if value == nil then
		value = 50
	end
	if value then
		flyers[player_name] = true
		tfm.exec.bindKeyboard(player_name, 1, true, true)
		tfm.exec.bindKeyboard(player_name, 1, false, true)
		tfm.exec.chatMessage("<i><ch>Jump to flap your wings!</ch></i>", player_name)
	else
		flyers[player_name] = nil
		tfm.exec.chatMessage("<i><ch2>Your feet are happy again.</ch2></i>", player_name)
	end
end
--- Get the target of the command, throwing on permission issue.
-- @private
function pshy.speedfly_GetTarget(user, target, perm_prefix)
	assert(type(perm_prefix) == "string")
	if not target then
		return user
	end
	if target == user then
		return user
	elseif not pshy.HavePerm(user, perm_prefix .. "-others") then
		error("you cant use this command on other players :c")
		return
	end
	return target
end
function eventKeyboard(player_name, key_code, down)
	if down then
		if key_code == 1 and flyers[player_name] then
			tfm.exec.movePlayer(player_name, 0, 0, true, 0, -55, false)
		elseif key_code == 0 and speedies[player_name] then
			tfm.exec.movePlayer(player_name, 0, 0, true, -(speedies[player_name]), 0, true)
		elseif key_code == 2 and speedies[player_name] then
			tfm.exec.movePlayer(player_name, 0, 0, true, speedies[player_name], 0, true)
		end
	end
end
function eventNewGame()
	if pshy.speedfly_reset_on_new_game then
		flyers = {}
		speedies = {}
	end
end
--- !speed
local function ChatCommandSpeed(user, speed, target)
	target = pshy.speedfly_GetTarget(user, target, "!speed")
	speed = speed or (speedies[target] and 0 or 50)
	assert(speed >= 0, "the minimum speed boost is 0")
	assert(speed <= 200, "the maximum speed boost is 200")
	pshy.speedfly_Speed(target, speed)
	return true
end
pshy.commands["speed"] = {func = ChatCommandSpeed, desc = "toggle fast acceleration mode", argc_min = 0, argc_max = 2, arg_types = {"number", "player"}, arg_names = {"speed", "target_player"}}
pshy.help_pages["pshy_speedfly"].commands["speed"] = pshy.commands["speed"]
pshy.perms.cheats["!speed"] = true
pshy.perms.admins["!speed-others"] = true
pshy.ChatCommandSpeed = ChatCommandSpeed -- @TODO: remove (Required now because another module may use that function)
--- !fly
local function ChatCommandFly(user, value, target)
	target = pshy.speedfly_GetTarget(user, target, "!fly")
	value = value or not flyers[target]
	pshy.speedfly_Fly(target, value)
	return true
end
pshy.commands["fly"] = {func = ChatCommandFly, desc = "toggle fly mode", argc_min = 0, argc_max = 2, arg_types = {"bool", "player"}}
pshy.help_pages["pshy_speedfly"].commands["fly"] = pshy.commands["fly"]
pshy.perms.cheats["!fly"] = true
pshy.perms.admins["!fly-others"] = true
pshy.ChatCommandFly = ChatCommandFly -- @TODO: remove (Required now because another module may use that function)
--- !tpp (teleport to player)
local function ChatCommandTpp(user, destination, target)
	target = pshy.speedfly_GetTarget(user, target, "!tpp")
	destination = pshy.FindPlayerNameOrError(destination)
	tfm.exec.movePlayer(target, tfm.get.room.playerList[destination].x, tfm.get.room.playerList[destination].y, false, 0, 0, true)
	return true, string.format("Teleported %s to %s.", target, destination)
end
pshy.commands["tpp"] = {func = ChatCommandTpp, desc = "teleport to a player", argc_min = 1, argc_max = 2, arg_types = {"player", "player"}, arg_names = {"destination", "target_player"}}
pshy.help_pages["pshy_speedfly"].commands["tpp"] = pshy.commands["tpp"]
pshy.perms.cheats["!tpp"] = true
pshy.perms.admins["!tpp-others"] = true
--- !tpl (teleport to location)
local function ChatCommandTpl(user, x, y, target)
	target = pshy.speedfly_GetTarget(user, target, "!tpl")
	tfm.exec.movePlayer(target, x, y, false, 0, 0, true)
	return true, string.format("Teleported %s to %d; %d.", target, x, y)
end
pshy.commands["tpl"] = {func = ChatCommandTpl, desc = "teleport to a location", argc_min = 2, argc_max = 3, arg_types = {"number", "number", "player"}, arg_names = {"x", "y", "target_player"}}
pshy.help_pages["pshy_speedfly"].commands["tpl"] = pshy.commands["tpl"]
pshy.perms.cheats["!tpl"] = true
pshy.perms.admins["!tpl-others"] = true
--- !coords
local function ChatCommandTpl(user)
	local tfm_player = tfm.get.room.playerList[user]
	return true, string.format("Coordinates: (%d; %d).", tfm_player.x, tfm_player.y)
end
pshy.commands["coords"] = {func = ChatCommandTpl, desc = "get your coordinates", argc_min = 0, argc_max = 0}
pshy.help_pages["pshy_speedfly"].commands["coords"] = pshy.commands["coords"]
pshy.perms.cheats["!coords"] = true
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_imagedb.lua")
function new_mod.Content()
--- pshy_imagedb.lua
--
-- Images available for TFM scripts.
-- Note: I did not made the images,
-- I only gathered and classified them in this script.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
-- @require pshy_commands.lua
-- @require pshy_help.lua
-- @require pshy_perms.lua
-- @require pshy_tfm_enum_fix.lua
--
-- @require_priority UTILS
--- Module Help Page:
pshy.help_pages["pshy_imagedb"] = {back = "pshy", title = "Image Search", text = "List of common module images.\n", commands = {}}
pshy.help_pages["pshy"].subpages["pshy_imagedb"] = pshy.help_pages["pshy_imagedb"]
--- Module Settings:
pshy.imagedb_max_search_results = 20		-- maximum search displayed results
--- Map of images.
-- The key is the image code.
-- The value is a table with the folowing fields:
--	- w: The pixel width of the picture.
--	- h: The pixel height of the picture (default to `w`).
pshy.imagedb_images = {}
-- example:
--pshy.imagedb_images["00000000000.png"] = {w = nil, h = nil, desc = ""}
-- Image used as a default by some scripts:
pshy.imagedb_images["15568238225.png"] = {meme = true, w = 40, h = 40, desc = "FUUU"}
--- Images:
-- See other files in this folder:
-- - `pshy_imagedb_misc.lua`
-- - `pshy_imagedb_bonuses.lua`
-- - `pshy_imagedb_deathmaze.lua`
-- - `pshy_imagedb_emoticons.lua`
--- Tell if an image should be oriented
function pshy.imagedb_IsOriented(image)
	if type(image) == "string" then
		image = pshy.imagedb_images[image]
	end
	assert(type(image) == "table", "wrong type " .. type(image))
	if image.oriented ~= nil then
		return image.oriented
	end
	if image.meme or image.emoticon or image.w <= 30 then
		return false
	end
	return true
end
--- Search for an image.
-- @private
-- This function is currently for testing only.
-- @param desc Text to find in the image's description.
-- @param words words to search for.
-- @return A list of images matching the search.
function pshy.imagedb_Search(words)
	local results = {}
	for image_name, image in pairs(pshy.imagedb_images) do
		local not_matching = false
		for i_word, word in pairs(words) do
			if not string.find(image.desc, word) and not image[word] then
				not_matching = true
				break
			end
		end
		if not not_matching then
			table.insert(results, image_name)
		end
	end
	return results
end
--- !searchimage [words...]
function pshy.changeimage_ChatCommandSearchimage(user, word)
	local words = pshy.StrSplit(word, ' ', 5)
	if #words >= 5 then
		return false, "You can use at most 4 words per search!"
	end
	if #words == 1 and #words[1] <= 1 then
		return false, "Please perform a more accurate search!"
	end
	local image_names = pshy.imagedb_Search(words)
	if #image_names == 0 then
		tfm.exec.chatMessage("No image found.", user)
	else
		for i_image, image_name in pairs(image_names) do
			if i_image > pshy.imagedb_max_search_results then
				tfm.exec.chatMessage("+ " .. tostring(#image_names - pshy.imagedb_max_search_results), user)
				break
			end
			local image = pshy.imagedb_images[image_name]
			tfm.exec.chatMessage(image_name .. "\t - " .. tostring(image.desc) .. " (" .. tostring(image.w) .. "," .. tostring(image.w or image.h) .. ")", user)
		end
	end
	return true
end
pshy.commands["searchimage"] = {func = pshy.changeimage_ChatCommandSearchimage, desc = "search for an image", argc_min = 1, argc_max = 1, arg_types = {"string"}}
pshy.help_pages["pshy_imagedb"].commands["searchimage"] = pshy.commands["searchimage"]
pshy.perms.cheats["!searchimage"] = true
--- Draw an image (wrapper to tfm.exec.addImage).
-- @public
-- @param image_name The image code (called imageId in te original function).
-- @param target On what game element to attach the image to.
-- @param center_x Center coordinates for the image.
-- @param center_y Center coordinates for the image.
-- @param player_name The player who will see the image, or nil for everyone.
-- @param width Width of the image.
-- @param height Height of the image.
-- @param angle The image's rotation (in radians).
-- @param height Opacity of the image.
-- @return The image ID.
function pshy.imagedb_AddImage(image_name, target, center_x, center_y, player_name, width, height, angle, alpha)
	if image_name == "none" then
		return nil
	end
	local image = pshy.imagedb_images[image_name] or pshy.imagedb_images["15568238225.png"]
	if image.left then
		width = -width
	end
	target = target or "!0"
	width = width or image.w
	height = height or image.h or image.w
	local x = center_x + ((width > 0) and 0 or math.abs(width))-- - width / 2
	local y = center_y + ((height > 0) and 0 or math.abs(height))-- - height / 2
	local sx = width / (image.w)
	local sy = height / (image.h or image.w)
	local anchor_x, anchor_y = 0.5, 0.5
	return tfm.exec.addImage(image_name, target, x, y, player_name, sx, sy, angle, alpha, anchor_x, anchor_y)
end
--- Draw an image (wrapper to tfm.exec.addImage) but keep the image dimentions (making it fit at least the given area).
-- @public
-- @param image_name The image code (called imageId in te original function).
-- @param target On what game element to attach the image to.
-- @param center_x Center coordinates for the image.
-- @param center_y Center coordinates for the image.
-- @param player_name The player who will see the image, or nil for everyone.
-- @param width Width of the image.
-- @param height Height of the image.
-- @param angle The image's rotation (in radians).
-- @param height Opacity of the image.
-- @return The image ID.
function pshy.imagedb_AddImageMin(image_name, target, center_x, center_y, player_name, min_width, min_height, angle, alpha)
	if image_name == "none" then
		return nil
	end
	local image = pshy.imagedb_images[image_name] or pshy.imagedb_images["15568238225.png"]
	if image.left then
		width = -width
	end
	target = target or "!0"
	local xsign = min_width / (math.abs(min_width))
	local ysign = min_height / (math.abs(min_height))
	width = min_width or image.w
	height = min_height or image.h or image.w
	local sx = width / (image.w)
	local sy = height / (image.h or image.w)
	local sboth = math.max(math.abs(sx), math.abs(sy))
	width = image.w * sboth * xsign
	height = (image.h or image.w) * sboth * ysign
	local x = center_x + ((width > 0) and 0 or math.abs(width))-- - width / 2
	local y = center_y + ((height > 0) and 0 or math.abs(height))-- - height / 2
	local anchor_x, anchor_y = 0.5, 0.5
	return tfm.exec.addImage(image_name, target, x, y, player_name, sboth * xsign, sboth, angle, alpha, anchor_x, anchor_y)
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_imagedb_bonuses.lua")
function new_mod.Content()
--- pshy_imagedb_misc.lua
--
-- Bonus images to extend `pshy_imagedb.lua`.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
-- @require pshy_imagedb.lua
--
-- @hardmerge
-- Bonuses (Pshy#3752)
pshy.imagedb_images["17bef4f49c5.png"] = {bonus = true, w = 30, h = 30, desc = "empty bonus"}
pshy.imagedb_images["17bf4b75aa7.png"] = {bonus = true, w = 30, h = 30, desc = "question bonus"}
pshy.imagedb_images["17bf4ba4ce5.png"] = {bonus = true, w = 30, h = 30, desc = "teleporter bonus"}
pshy.imagedb_images["17bf4b9e11d.png"] = {bonus = true, w = 30, h = 30, desc = "crate bonus"}
pshy.imagedb_images["17bf4b9af56.png"] = {bonus = true, w = 30, h = 30, desc = "high speed bonus"}
pshy.imagedb_images["17bf4b977f5.png"] = {bonus = true, w = 30, h = 30, desc = "ice cube bonus"}
pshy.imagedb_images["17bf4b94d8a.png"] = {bonus = true, w = 30, h = 30, desc = "snowflake bonus"}
pshy.imagedb_images["17bf4b91c35.png"] = {bonus = true, w = 30, h = 30, desc = "broken heart bonus"}
pshy.imagedb_images["17bf4b8f9e4.png"] = {bonus = true, w = 30, h = 30, desc = "heart bonus"}
pshy.imagedb_images["17bf4b8c42d.png"] = {bonus = true, w = 30, h = 30, desc = "feather bonus"}
pshy.imagedb_images["17bf4b89eba.png"] = {bonus = true, w = 30, h = 30, desc = "cross"}
pshy.imagedb_images["17bf4b868c3.png"] = {bonus = true, w = 30, h = 30, desc = "jumping mouse bonus"}
pshy.imagedb_images["17bf4b80fc3.png"] = {bonus = true, w = 30, h = 30, desc = "balloon bonus"}
pshy.imagedb_images["17bef4f49c5.png"] = {bonus = true, w = 30, h = 30, desc = "empty bonus"}
pshy.imagedb_images["17bf4b7ddd6.png"] = {bonus = true, w = 30, h = 30, desc = "triggered mouse trap"}
pshy.imagedb_images["17bf4b7a091.png"] = {bonus = true, w = 30, h = 30, desc = "mouse trap"}
pshy.imagedb_images["17bf4b7250e.png"] = {bonus = true, w = 30, h = 30, desc = "wings bonus"}
pshy.imagedb_images["17bf4b6f226.png"] = {bonus = true, w = 30, h = 30, desc = "transformations bonus"}
pshy.imagedb_images["17bf4b67579.png"] = {bonus = true, w = 30, h = 30, desc = "grow bonus"}
pshy.imagedb_images["17bf4b63aaa.png"] = {bonus = true, w = 30, h = 30, desc = "shrink bonus"}
pshy.imagedb_images["17bf4c421bb.png"] = {bonus = true, w = 30, h = 30, desc = "white flag bonus"}
pshy.imagedb_images["17e59dbef1e.png"] = {bonus = true, w = 30, h = 30, desc = "racing flag bonus"}
pshy.imagedb_images["17bf4f3f2fb.png"] = {bonus = true, w = 30, h = 30, desc = "v check"}
pshy.imagedb_images["17e53fb43dc.png"] = {bonus = true, w = 30, h = 30, desc = "cannonball bonus"}
pshy.imagedb_images["17e59ba43a6.png"] = {bonus = true, w = 30, h = 30, desc = "fish bonus"}
pshy.imagedb_images["17ebfdb85bd.png"] = {bonus = true, w = 30, h = 30, desc = "mouse skull bonus"}
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_bonuses.lua")
function new_mod.Content()
--- pshy_bonus.lua
--
-- Add custom bonuses.
--
-- Either use `pshy.bonuses_SetList()` to set the current bonus list.
-- Or add them individually with `pshy.bonuses_Add()`.
--
-- Fields:
--	x (bonus only):				int, bonus location
--	y (bonus only):				int, bonus location
--	image:						string, bonus image name in pshy_imagedb
--	func:						function to call when the bonus is picked
--								if func returns false then the bonus will not be considered picked by the script (but TFM will)
--	shared:						bool, do this bonus disapear when picked by any player
--	remain:						bool, do this bonus never disapear, even when picked
--	enabled (bonus only):		if this bonus is enabled/visible by default
--	autorespawn (bonus only):	bool, do this respawn automatically
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
-- @require pshy_imagedb_bonuses.lua
--
-- @require_priority UTILS
pshy = pshy or {}
--- Bonus types.
-- @public
-- List of bonus types and informations.
pshy.bonuses_types = {}						-- default bonus properties
--- Bonus List.
-- Keys: The bonus ids.
-- Values: A table with the folowing fields:
--	- type: Bonus type, as a table.
--	- x: Bonus coordinates.
--	- y: Bonus coordinates.
--	- enabled: Is it enabled by default (true == always, false == never/manual, nil == once only).
pshy.bonuses_list	= {}					-- list of ingame bonuses
pshy.bonuses_taken	= {}					-- set of taken bonus indices (non-shared bonuses use a table)
--- Internal Use:
pshy.bonuses_players_image_ids = {}
--- Set the list of bonuses, and show them.
-- @public
function pshy.bonuses_SetList(bonus_list)
	pshy.bonuses_DisableAll()
	pshy.bonuses_list = pshy.ListCopy(bonus_list)
	pshy.bonuses_EnableAll()
end
--- Create and enable a bonus.
-- @public
-- Either use this function or `pshy.bonuses_SetList`, but not both.
-- @param bonus_type The name or table corresponding to the bonus type.
-- @param bonus_x The bonus location.
-- @param bonus_y The bonus location.
-- @param enabled Is the bonus enabled for all players by default (nil is yes but not for new players).
-- @return The id of the created bonus.
function pshy.bonuses_Add(bonus_type_name, bonus_x, bonus_y, bonus_enabled, angle)
	local bonus_type = bonus_type_name
	if type(bonus_type) == "string" then
		assert(pshy.bonuses_types[bonus_type], "invalid bonus type " .. tostring(bonus_type))
		bonus_type = pshy.bonuses_types[bonus_type]
	end
	assert(type(bonus_type) == "table")
	-- insert
	local new_id = #pshy.bonuses_list + 1 -- @TODO: this doesnt allow removing bonuses (IN FACT IT LIMITS ALOT)
	local new_bonus = {id = new_id, type = bonus_type_name, x = bonus_x, y = bonus_y, enabled = bonus_enabled, angle = angle or 0}
	pshy.bonuses_list[new_id] = new_bonus
	-- show
	if bonus_enabled ~= false then
		pshy.bonuses_Enable(new_id)
	end
	return new_id
end
--- Enable a bonus.
-- @public
-- When a bonus is enabled, it can be picked by players.
function pshy.bonuses_Enable(bonus_id, player_name)
	assert(type(bonus_id) == "number")
	if player_name == nil then
		for player_name in pairs(tfm.get.room.playerList) do
			pshy.bonuses_Enable(bonus_id, player_name)
		end
		return
	end
	pshy.bonuses_players_image_ids[player_name] = pshy.bonuses_players_image_ids[player_name] or {}
	local bonus = pshy.bonuses_list[bonus_id]
	local ids = pshy.bonuses_players_image_ids[player_name]
	-- get bonus type
	local bonus_type = bonus.type
	if type(bonus_type) == "string" then
		assert(pshy.bonuses_types[bonus_type], "invalid bonus type " .. tostring(bonus_type))
		bonus_type = pshy.bonuses_types[bonus_type]
	end
	assert(type(bonus_type) == 'table', "bonus type must be a table or a string")
	-- if already shown
	if ids[bonus_id] ~= nil then
		pshy.bonuses_Disable(bonus_id, player_name)
	end
	-- add bonus
	tfm.exec.addBonus(0, bonus.x, bonus.y, bonus_id, 0, false, player_name)
	-- add image
	--ids[bonus_id] = tfm.exec.addImage(bonus.image or bonus_type.image, "!0", bonus.x - 15, bonus.y - 20, player_name) -- todo: location
	ids[bonus_id] = pshy.imagedb_AddImage(bonus.image or bonus_type.image, "!0", bonus.x, bonus.y, player_name, nil, nil, (bonus.angle or 0) * math.pi * 2 / 360, 1.0)
	-- reenabling a bonus cause it to be non-taken
	if bonus.shared or bonus_type.shared then
		pshy.bonuses_taken[bonus_id] = nil
	else
		local player_set = pshy.bonuses_taken[bonus_id]
		if player_set then
			player_set[player_name] = nil
		end
	end
end
--- Hide a bonus.
-- @public
-- This prevent the bonus from being picked, without deleting it.
function pshy.bonuses_Disable(bonus_id, player_name)
	assert(type(bonus_id) == "number")
	if player_name == nil then
		for player_name in pairs(tfm.get.room.playerList) do
			pshy.bonuses_Disable(bonus_id, player_name)
		end
		return
	end
	if not pshy.bonuses_players_image_ids[player_name] then
		return
	end
	local bonus = pshy.bonuses_list[bonus_id]
	local ids = pshy.bonuses_players_image_ids[player_name]
	-- if already hidden
	if ids[bonus_id] == nil then
		return
	end
	-- remove bonus
	tfm.exec.removeBonus(bonus_id, player_name)
	-- remove image
	tfm.exec.removeImage(ids[bonus_id])
end
--- Show all bonuses, except the ones with `visible == false`.
-- @private
function pshy.bonuses_EnableAll(player_name)
	for bonus_id, bonus in pairs(pshy.bonuses_list) do
		if not bonus.hidden then
			pshy.bonuses_Enable(bonus_id, player_name)
		end
	end
end
--- Disable all bonuses for all players.
-- @private
function pshy.bonuses_DisableAll(player_name)
	for bonus_id, bonus in pairs(pshy.bonuses_list) do
		pshy.bonuses_Disable(bonus_id, player_name)
	end
end
--- TFM event eventPlayerBonusGrabbed.
function eventPlayerBonusGrabbed(player_name, id)
	if id == 0 then
		print(string.format("DEBUG: %s grabbed a bonus with id %d", player_name, id))
		return
	end
	local bonus = pshy.bonuses_list[id]
	if not bonus then
		print_error("%s grabbed non-existing bonus with id %d", player_name, id)
		return
	end
	local bonus_type = bonus.type
	if type(bonus_type) == "string" then
		assert(pshy.bonuses_types[bonus_type], "invalid bonus type " .. tostring(bonus_type))
		bonus_type = pshy.bonuses_types[bonus_type]
	end
	-- checking if that bonus was already taken
	if bonus.shared or bonus_type.shared then
		if pshy.bonuses_taken[id] then
			return false
		end
		pshy.bonuses_taken[id] = true
	else
		if not pshy.bonuses_taken[id] then
			pshy.bonuses_taken[id] = {}
		end
		local player_set = pshy.bonuses_taken[id]
		if player_set and player_set[player_name] then
			return false
		end
		player_set[player_name] = true
	end
	-- running the callback
	local func = bonus.func or bonus_type.func
	local pick_rst = nil
	if func then
		pick_rst = func(player_name, bonus)
	end
	-- disable bonus
	if pick_rst ~= false then -- if func returns false then dont unspawn the bonus
		if bonus.shared or (bonus.shared == nil and bonus_type.shared) then
			pshy.bonuses_Disable(id, nil)
			if bonus.remain or (bonus.remain == nil and bonus_type.remain) then
				pshy.bonuses_Enable(id, nil)
			end
		else
			pshy.bonuses_Disable(id, player_name)
			if bonus.remain or (bonus.remain == nil and bonus_type.remain) then
				pshy.bonuses_Enable(id, player_name)
			end
		end
	end
end
--- TFM event eventNewGame.
function eventNewGame()
	pshy.bonuses_list = {}
	pshy.bonuses_players_image_ids = {}
	pshy.bonuses_taken = {}
end
--- TFM event eventPlayerRespawn.
function eventPlayerRespawn(player_name)
	for bonuses_id, bonus in pairs(pshy.bonuses_list) do
		if bonus.respawn then
			pshy.bonuses_Enable(bonuses_id, player_name)
		end
	end
end
function eventNewPlayer(player_name)
	for bonus_id, bonus in pairs(pshy.bonuses_list) do
		assert(type(bonus) == "table")
		local bonus_type = bonus.type
		if type(bonus_type) == "string" then
			assert(pshy.bonuses_types[bonus_type], "invalid bonus type " .. tostring(bonus_type))
			bonus_type = pshy.bonuses_types[bonus_type]
		end
		assert(type(bonus) == "table" or bonus_type == nil)
		if bonus.respawn then
			pshy.bonuses_Enable(bonus_id, player_name)
		elseif bonus.shared or (bonus_type and bonus_type.shared) then
			if not pshy.bonuses_taken[bonus_id] then
				pshy.bonuses_Enable(bonus_id, player_name)
			end
		else
			local player_set = pshy.bonuses_taken[bonus_id]
			if not player_set or not player_set[player_name] then
				pshy.bonuses_Enable(bonus_id, player_name)
			end
		end
	end
end
--- TFM event eventPlayerLeft.
function eventPlayerLeft(player_name)
	pshy.bonuses_DisableAll(player_name) -- @todo: is this required?
	pshy.bonuses_players_image_ids[player_name] = nil
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_newgame.lua")
function new_mod.Content()
--- pshy_newgame.lua
--
-- Override and replace `tfm.exec.newGame`.
-- Adds custom map features.
-- Calls `eventGameEnded` just before a map change.
--
-- Listed map and rotation tables can have the folowing fields:
--	- begin_func: Function to run when the map started.
--	- end_func: Function to run when the map stopped.
--	- replace_func: Function to run on the map's xml (or name if not present) that is supposed to return the final xml.
--	- autoskip: If true, the map will change at the end of the timer.
--	- duration: Duration of the map.
--	- shamans: Count of shamans (Currently, only 0 is supported to disable the shaman).
--	- xml (maps only): The true map's xml code.
--	- hidden (rotations only): Do not show the rotation is being used to players.
--	- modules: list of module names to enable while the map is playing (to trigger events).
--	- troll: bool telling if the rotation itself is a troll (may help other modules about how to handle the rotation).
--	- unique_items: bool telling if the items are supposed to be unique (duplicates are removed on eventInit).
--
-- @author TFM:Pshy#3752 DC:Pshy#7998 (script)
--
-- @require pshy_bonuses.lua
-- @require pshy_commands.lua
-- @require pshy_help.lua
-- @require pshy_mapdb.lua
-- @optional_require pshy_mapinfo.lua
-- @require pshy_print.lua
-- @require pshy_rotation.lua
-- @require pshy_utils_tables.lua
-- @require pshy_utils_tfm.lua
--
-- @require_priority WRAPPER
--
-- @TODO: replace pshy namespace function by locals when appropriate
-- @TODO: override disableAutoNewGame() and override its behavior (in pshy_newgame_ext)
-- @TODO: spawn the shamans from `pshy.mapinfo.shaman_spawns` (in pshy_newgame_ext)
-- @TODO: move bonus spawning to ext ?
-- @TODO: check what feature do utility support
--- Module Help Page:
pshy.help_pages["pshy_newgame"] = {back = "pshy", title = "pshy_newgame", text = "Replaces tfm.exec.newGame, adding features.\n", commands = {}}
pshy.help_pages["pshy"].subpages["pshy_newgame"] = pshy.help_pages["pshy_newgame"]
--- Module Settings:
pshy.newgame_default = "default"			-- default rotation, can be a rotation of rotations
pshy.mapdb_rotations["default"]				= {hidden = true, items = {"transformice"}}		-- default rotation, can only use other rotations, no maps
pshy.newgame_default_rotation 				= pshy.mapdb_rotations["default"]				--
pshy.newgame_delay_next_map					= false
pshy.newgame_error_map						= "error_map"
--- Settings for tfm overriden features:
local simulated_tfm_auto_new_game = true
local simulated_tfm_auto_shaman = true
--- Internal Use:
pshy.newgame_current_settings = {}
pshy.newgame_current_settings.shamans = nil
pshy.newgame_current_settings.map_name = nil
pshy.newgame_current_settings.map = nil
pshy.newgame_current_settings.autoskip = true
pshy.newgame_current_settings.duration = 60
pshy.newgame_current_settings.begin_funcs = {}
pshy.newgame_current_settings.end_funcs = {}
pshy.newgame_current_settings.replace_func = nil
pshy.newgame_current_settings.modules = {}			-- list of module names enabled for the map that needs to be disabled
pshy.newgame_current_settings.background_color = nil
pshy.newgame_current_settings.title = nil
pshy.newgame_current_settings.title_color = nil
pshy.newgame_current_settings.author = nil
pshy.newgame_event_new_game_triggered = false
pshy.newgame_next = nil
pshy.newgame_force_next = false
pshy.newgame_current_rotations_names = {}		-- set rotation names we went by when choosing the map
local newgame_called				= false
local players_alive_changed			= false
--- Local override of `tfm.exec.newGame`.
-- The purpose is only to know when the original have been called.
-- This will also prevent from loading a map if another is being loaded already.
-- This is an override for local use, the override for other modules is different.
local jshcjwsbwjc = tfm.exec.newGame
tfm.exec.newGame = function(mapcode, ...)
	if newgame_called then
		print_warn("pshy_newgame: tfm.exec.newGame was called while the game was already loading a new map.")
		--return
	end
	newgame_called = true
	--print_debug("pshy_newgame: tfm.exec.newGame(%s)", tostring(mapcode))
	return jshcjwsbwjc(mapcode, ...)
end
--- Override for `tfm.exec.disableAutoNewGame()`.
local function override_tfm_exec_disableAutoNewGame(disable)
	--print_debug("override_tfm_exec_disableAutoNewGame(%s)", tostring(disable))
	if disable == nil then
		disable = true
	end
	simulated_tfm_auto_new_game = not disable
end
tfm.exec.disableAutoNewGame(true)
tfm.exec.disableAutoNewGame = override_tfm_exec_disableAutoNewGame
--- Override for `tfm.exec.disableAutoShaman()`.
local function override_tfm_exec_disableAutoShaman(disable)
	--print_debug("override_tfm_exec_disableAutoShaman(%s)", tostring(disable))
	if disable == nil then
		disable = true
	end
	simulated_tfm_auto_shaman = not disable
end
tfm.exec.disableAutoShaman(false)
local OriginalTFMDisableAutoShaman = tfm.exec.disableAutoShaman
tfm.exec.disableAutoShaman = override_tfm_exec_disableAutoShaman
--- Set the next map.
-- This map will be used on the next call to tfm.exec.newGame().
-- @param code Map code.
-- @param force Should the map be forced (even if another map is chosen).
function pshy.newgame_SetNextMap(code, force)
	pshy.newgame_next = code
	pshy.newgame_force_next = force or false
end
--- End the previous map.
-- @private
-- @param aborted true if the map have not even been started.
local function EndMap(aborted)
	if not aborted then
		for i_func, end_func in ipairs(pshy.newgame_current_settings.end_funcs) do
			end_func(pshy.newgame_current_settings.map_name)
		end
		if eventGameEnded then
			eventGameEnded()
		end
	end
	pshy.newgame_current_settings.shamans = nil
	OriginalTFMDisableAutoShaman(not simulated_tfm_auto_shaman)
	pshy.newgame_current_settings.map_name = nil
	pshy.newgame_current_settings.map = nil
	pshy.newgame_current_settings.autoskip = nil
	pshy.newgame_current_settings.duration = nil
	pshy.newgame_current_settings.begin_funcs = {}
	pshy.newgame_current_settings.end_funcs = {}
	pshy.newgame_current_settings.replace_func = nil
	pshy.newgame_current_settings.background_color = nil
	pshy.newgame_current_settings.title = nil
	pshy.newgame_current_settings.title_color = nil
	pshy.newgame_current_settings.author = nil
	pshy.newgame_current_rotations_names = {}
	pshy.merge_DisableModules(pshy.newgame_current_settings.modules)
	pshy.newgame_current_settings.modules = {}
	-- On every new game:
	--for player_name in pairs(tfm.get.room.playerList) do
		--tfm.exec.changePlayerSize(player_name, 1.0)
		--tfm.exec.giveTransformations(player_name, false)
		--tfm.exec.linkMice(player_name, player_name, false) -- TODO: check player.soulmate ?
	--end
	-- clean tfm.get.room.xmlMapInfo because TFM doesnt
	tfm.get.room.xmlMapInfo = nil
end
--- TFM.exec.newGame override.
-- @private
-- @brief mapcode Either a map code or a map rotation code.
local tfm_exec_newGame = tfm.exec.newGame
tfm.exec.newGame = function(mapcode, ...)
	--print_debug("pshy.newgame_newGame(%s)", tostring(mapcode))
	EndMap()
	pshy.newgame_event_new_game_triggered = false
	return pshy.newgame_Next(mapcode)
end
--- Add custom settings to the next map.
-- Some maps or map rotations have special settings.
-- This function handle both of them
local function AddCustomMapSettings(t)
	if t.autoskip ~= nil then
		pshy.newgame_current_settings.autoskip = t.autoskip
	end
	if t.shamans ~= nil then
		assert(t.shamans == 0, "only a shaman count of 0 or nil is supported yet")
		pshy.newgame_current_settings.shamans = t.shamans
		OriginalTFMDisableAutoShaman(true)
	end
	if t.duration ~= nil then
		pshy.newgame_current_settings.duration = t.duration
	end
	if t.begin_func ~= nil then
		table.insert(pshy.newgame_current_settings.begin_funcs, t.begin_func)
	end
	if t.end_func ~= nil then
		table.insert(pshy.newgame_current_settings.end_funcs, t.end_func)
	end
	if t.replace_func ~= nil then
		pshy.newgame_current_settings.replace_func = t.replace_func
	end
	if t.background_color ~= nil then
		pshy.newgame_current_settings.background_color = t.background_color
	end
	if t.title ~= nil then
		pshy.newgame_current_settings.title = t.title
	end
	if t.title_color ~= nil then
		pshy.newgame_current_settings.title_color = t.title_color
	end
	if t.author ~= nil then
		pshy.newgame_current_settings.author = t.author
	end
	if t.modules then
		for i, module_name in pairs(t.modules) do
			table.insert(pshy.newgame_current_settings.modules, module_name)
		end
	end
end
--- pshy.newgame_newGame but only for maps listed to this module.
-- @private
local function NextDBMap(map_name)
	local map = pshy.mapdb_maps[map_name]
	AddCustomMapSettings(map)
	pshy.newgame_current_settings.map_name = map_name
	pshy.newgame_current_settings.map = map
	ui.setBackgroundColor("#010101") -- @TODO: make this a map setting
	local map_xml
	if map.xml then
		map_xml = map.xml
		tfm.get.room.xmlMapInfo = {}
		if string.sub(map.xml, 1, 1) == "<" then
			tfm.get.room.xmlMapInfo.xml = map.xml
		end
		tfm.get.room.xmlMapInfo.author = map.author
	else
		map_xml = map_name
	end
	if pshy.newgame_current_settings.replace_func then
		map_xml = pshy.newgame_current_settings.replace_func(map.xml)
	end
	pshy.merge_EnableModules(pshy.newgame_current_settings.modules)
	return tfm_exec_newGame(map_xml)
end
--- pshy.newgame_newGame but only for rotations listed to this module.
-- @private
local function NextDBRotation(rotation_name)
	if rotation_name == "default" and #pshy.newgame_default_rotation.items == nil then
		-- empty rotation, just not changing map
		return nil
	end
	if pshy.newgame_current_rotations_names[rotation_name] then
		print_warn("Cyclic map rotation (%s)! Running newGame(error_map)!", rotation_name)
		EndMap(true)
		return tfm_exec_newGame(pshy.newgame_error_map)
	end
	pshy.newgame_current_rotations_names[rotation_name] = true
	local rotation = pshy.mapdb_GetRotation(rotation_name)
	AddCustomMapSettings(rotation)
	pshy.newgame_current_rotation_name = rotation_name
	pshy.newgame_current_rotation = rotation
	local next_map_name = pshy.rotation_Next(rotation)
	return pshy.newgame_Next(next_map_name)
end
--- Setup the next map (possibly a rotation), calling newGame.
-- @private
function pshy.newgame_Next(mapcode)
	if mapcode == nil or pshy.newgame_force_next then
		if pshy.newgame_next then
			mapcode = pshy.newgame_next
		else
			mapcode = pshy.newgame_default
		end
	end
	pshy.newgame_force_next = false
	pshy.newgame_next = nil
	if pshy.mapdb_maps[mapcode] then
		return NextDBMap(mapcode)
	end
	local mapcode_number = tonumber(mapcode)
	if mapcode_number and pshy.mapdb_maps[mapcode_number] then
		return NextDBMap(mapcode_number)
	end
	local next_rotation = pshy.mapdb_GetRotation(mapcode)
	if next_rotation then
		return NextDBRotation(mapcode)
	end
	if tonumber(mapcode) then
		pshy.newgame_current_settings.map_name = mapcode
		pshy.merge_EnableModules(pshy.newgame_current_settings.modules)
		return tfm_exec_newGame(mapcode)
	end
	if string.sub(mapcode, 1, 1) == "<" then
		tfm.get.room.xmlMapInfo = {}
		tfm.get.room.xmlMapInfo.xml = mapcode
		return tfm_exec_newGame(mapcode)
	end
	pshy.merge_EnableModules(pshy.newgame_current_settings.modules)
	return tfm_exec_newGame(mapcode)
end
--- TFM event eventNewGame.
function eventNewGame()
	newgame_called = false
	if not pshy.newgame_event_new_game_triggered then
		if pshy.newgame_current_settings.map and pshy.newgame_current_settings.map.bonuses then
			if pshy.bonuses_SetList then
				pshy.bonuses_SetList(pshy.newgame_current_settings.map.bonuses)
			end
		end
		for i_func, begin_func in ipairs(pshy.newgame_current_settings.begin_funcs) do
			begin_func(pshy.newgame_current_settings.map_name)
		end
		if pshy.newgame_current_settings.duration then
			tfm.exec.setGameTime(pshy.newgame_current_settings.duration, true)
		end
		if pshy.newgame_current_settings.background_color then
			ui.setBackgroundColor(pshy.newgame_current_settings.background_color)
		end
		local author = pshy.newgame_current_settings.author or (pshy.mapinfo and pshy.mapinfo.author)
		local title = pshy.newgame_current_settings.title or (pshy.mapinfo and pshy.mapinfo.title) or pshy.newgame_current_settings.map_name
		if author or title then
			local full_map_name = ""
			local title_color = pshy.newgame_current_settings.title_color or (pshy.mapinfo and pshy.mapinfo.title_color)
			if author then
				full_map_name = full_map_name .. author
			end
			title = title or pshy.newgame_current_settings.map_name
			if pshy.mapinfo and not title then
				title = pshy.mapinfo.current_map
			end
			if title then
				if author then
					full_map_name = full_map_name .. "<bl> - "
				end
				if title_color then
					full_map_name = full_map_name .. string.format('<font color="%s">', title_color)
				end
				full_map_name = full_map_name .. title
				if title_color then
					full_map_name = full_map_name .. "</font>"
				end
			end
			ui.setMapName(full_map_name)
		end
	else
		-- tfm loaded a new map
		print_warn("TFM loaded a new game despite the override")
		EndMap()
		if pshy.newgame_current_settings.map then
			OriginalTFMDisableAutoShaman(false)
		end
	end
	pshy.newgame_event_new_game_triggered = true
	players_alive_changed = false
end
--- TFM event eventLoop.
-- Skip the map when the timer is 0.
function eventLoop(time, time_remaining)
	if newgame_called then
		print_warn("eventLoop called between newGame() and eventNewGame()")
		--return
	end
	if time_remaining <= 400 and time > 3000 then
		if (pshy.newgame_current_settings.autoskip ~= false and simulated_tfm_auto_new_game) or pshy.newgame_current_settings.autoskip then
			--print_debug("changing map because time is low")
			tfm.exec.newGame(nil)
		end
	end
	if newgame_called then
		return
	end
	if players_alive_changed then
		local players_alive = pshy.CountPlayersAlive()
		if players_alive == 0 then
			if (pshy.newgame_current_settings.autoskip ~= false and simulated_tfm_auto_new_game) or pshy.newgame_current_settings.autoskip then
				tfm.exec.setGameTime(5, false)
				if not pshy.newgame_delay_next_map then
					--print_debug("changing map because hmm here...")
					tfm.exec.newGame(nil)
				end
			end
		end
	end
end
function eventNewPlayer(player_name)
	if pshy.newgame_current_settings.background_color then
		ui.setBackgroundColor(pshy.newgame_current_settings.background_color)
	end
end
--- !next [map]
local function ChatCommandNext(user, code, force)
	pshy.newgame_SetNextMap(code, force)
	return true, string.format("The next map or rotation will be %s.", code)
end
pshy.commands["next"] = {func = ChatCommandNext, desc = "set the next map to play (no param to cancel)", argc_min = 1, argc_max = 2, arg_types = {"string", "bool"}, arg_names = {"map code", "force"}}
pshy.help_pages["pshy_newgame"].commands["next"] = pshy.commands["next"]
pshy.perms.admins["!next"] = true
pshy.commands_aliases["np"] = "next"
pshy.commands_aliases["npp"] = "next"
--- !skip [map]
local function ChatCommandSkip(user, code)
	pshy.newgame_next = code or pshy.newgame_next
	pshy.newgame_force_next = code ~= nil
	if not pshy.newgame_next and #pshy.newgame_default_rotation.items == 0 then
		return false, "First use !rotw to set the rotations you want to use (use !rots for a list)."
	end
	tfm.exec.setGameTime(0, false)
	tfm.exec.newGame(pshy.newgame_next)
	return true
end
pshy.commands["skip"] = {func = ChatCommandSkip, desc = "play a different map right now", argc_min = 0, argc_max = 1, arg_types = {"string"}}
pshy.help_pages["pshy_newgame"].commands["skip"] = pshy.commands["skip"]
pshy.perms.admins["!skip"] = true
pshy.commands_aliases["map"] = "skip"
--- !repeat
local function ChatCommandRepeat(user)
	map = pshy.newgame_current_settings.map_name
	if not map then
		return false, "Something wrong happened."
	end
	return ChatCommandSkip(user, pshy.newgame_current_settings.map_name or pshy.mapinfo.arg1)
end
pshy.commands["repeat"] = {func = ChatCommandRepeat, desc = "repeat the last map", argc_min = 0, argc_max = 0}
pshy.help_pages["pshy_newgame"].commands["repeat"] = pshy.commands["repeat"]
pshy.perms.admins["!repeat"] = true
pshy.commands_aliases["r"] = "repeat"
pshy.commands_aliases["replay"] = "repeat"
--- !rotations
local function ChatCommandRotations(user)
	pshy.Answer("Available rotations:", user)
	local keys = pshy.TableSortedKeys(pshy.mapdb_rotations)
	for i_rot, rot_name in pairs(keys) do
		local rot = pshy.mapdb_GetRotation(rot_name)
		if rot ~= pshy.newgame_default_rotation then
			local count = pshy.TableCountValue(pshy.newgame_default_rotation.items, rot_name)
			local s = ((count > 0) and "<vp>" or "<fc>")
			s = s .. ((count > 0) and ("<b>  " .. tostring(count) .. "</b> \t") or "  - \t\t") .. rot_name
			s = s .. ((count > 0) and "</vp>" or "</fc>")
			s = s ..  ": " .. tostring(rot.desc) .. " (" .. #rot.items .. "#)"
			tfm.exec.chatMessage(s, user)
		end
	end
	return true
end
pshy.commands["rotations"] = {func = ChatCommandRotations, desc = "list available rotations", argc_min = 0, argc_max = 0}
pshy.help_pages["pshy_newgame"].commands["rotations"] = pshy.commands["rotations"]
pshy.perms.admins["!rotations"] = true
pshy.commands_aliases["rots"] = "rotations"
--- !rotationweigth <name> <value>
local function ChatCommandRotw(user, rotname, w)
	if not pshy.mapdb_GetRotation(rotname) then
		return false, "Unknown rotation."
	end
	if rotname == "default" then
		return false, "It's not rotationception."
	end
	if w == nil then
		w = (pshy.TableCountValue(pshy.newgame_default_rotation.items, rotname) ~= 0) and 0 or 1
	end
	if w < 0 then
		return false, "Use 0 to disable the rotation."
	end
	if w > 100 then
		return false, "The maximum weight is 100."
	end
	pshy.ListRemoveValue(pshy.newgame_default_rotation.items, rotname)
	if w > 0 then
		for i = 1, w do
			table.insert(pshy.newgame_default_rotation.items, rotname)
		end
	end
	pshy.rotation_Reset(pshy.newgame_default_rotation)
	return true, "Changed a map frequency."
end
pshy.commands["rotationweigth"] = {func = ChatCommandRotw, desc = "set a rotation's frequency weight", argc_min = 1, argc_max = 2, arg_types = {"string", "number"}}
pshy.help_pages["pshy_newgame"].commands["rotationweigth"] = pshy.commands["rotationweigth"]
pshy.perms.admins["!rotationweigth"] = true
pshy.commands_aliases["rotw"] = "rotationweigth"
--- !rotationclean [rotation]
local function ChatCommandRotc(user, rotname)
	if rotname and not pshy.mapdb_GetRotation(rotname) then
		return false, string.format("Rotation %s does not exist!", rotname)
	end
	pshy.newgame_default_rotation.items = {}
	if rotname then
		table.insert(pshy.newgame_default_rotation.items, rotname)
		return true, string.format("Disabled all rotations and enabled %s.", rotname)
	end
	return true, "Disabled all rotations."
end
pshy.commands["rotationclean"] = {func = ChatCommandRotc, desc = "clear all rotations, and optionaly set a new one", argc_min = 0, argc_max = 1, arg_types = {"string"}}
pshy.help_pages["pshy_newgame"].commands["rotationclean"] = pshy.commands["rotationclean"]
pshy.perms.admins["!rotationclean"] = true
pshy.commands_aliases["rotc"] = "rotationclean"
pshy.newgame_ChatCommandRotc = ChatCommandRotc -- @deprecated
function eventPlayerDied(player_name)
	players_alive_changed = true
	tfm.get.room.playerList[player_name].isDead = true
end
function eventPlayerWon(player_name)
	players_alive_changed = true
	tfm.get.room.playerList[player_name].isDead = true
end
function eventInit()
	for i_rot, rot in pairs(pshy.mapdb_rotations) do
		-- @TODO use a custom compare function
		--if rot.unique_items then
		--	table.sort(rot.items)
		--	pshy.SortedListRemoveDuplicates(rot.items)
		--end
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_checkpoints.lua")
function new_mod.Content()
--- pshy_checkpoints.lua
--
-- Adds respawn features.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
-- @namespace pshy
-- @require pshy_commands.lua
-- @require pshy_help.lua
--- Module Help Page:
pshy.help_pages["pshy_checkpoints"] = {back = "pshy", title = "Checkpoints", text = nil, commands = {}}
pshy.help_pages["pshy"].subpages["pshy_checkpoints"] = pshy.help_pages["pshy_checkpoints"]
--- Module Settings:
pshy.checkpoints_reset_on_new_game = true
--- Internal use:
pshy.players = pshy.players or {}			-- adds checkpoint_x, checkpoint_y, checkpoint_hasCheese
local just_dead_players = {}
--- Set the checkpoint of a player.
-- @param player_name The player's name.
-- @param x Optional player x location.
-- @param y Optional player y location.
-- @param hasCheese Optional hasCheese tfm player property.
function pshy.checkpoints_SetPlayerCheckpoint(player_name, x, y, hasCheese)
	pshy.players[player_name] = pshy.players[player_name] or {}
	local player = pshy.players[player_name]
	x = x or tfm.get.room.playerList[player_name].x
	y = y or tfm.get.room.playerList[player_name].y
	hasCheese = hasCheese or tfm.get.room.playerList[player_name].hasCheese
	player.checkpoint_x = x
	player.checkpoint_y = y
	player.checkpoint_hasCheese = hasCheese
end
--- Set the checkpoint of a player.
-- @param player_name The player's name.
function pshy.checkpoints_UnsetPlayerCheckpoint(player_name)
	local player = pshy.players[player_name]
	player.checkpoint_x = nil
	player.checkpoint_y = nil
	player.checkpoint_hasCheese = nil
end
--- Teleport a player to its checkpoint.
-- Also gives him the cheese if he had it.
-- @param player_name The player's name.
-- @param x Optional player x location.
-- @param y Optional player y location.
function pshy.checkpoints_PlayerCheckpoint(player_name)
	local player = pshy.players[player_name]
	if player.checkpoint_x then
		tfm.exec.respawnPlayer(player_name)
		tfm.exec.movePlayer(player_name, player.checkpoint_x, player.checkpoint_y, false, 0, 0, true)
		if player.checkpoint_hasCheese then
			tfm.exec.giveCheese(player_name)
		end
	end
end
--- !checkpoint
pshy.commands["gotocheckpoint"] = {func = pshy.checkpoints_PlayerCheckpoint, desc = "teleport to your checkpoint if you have one", argc_min = 0, argc_max = 0, arg_types = {}}
pshy.help_pages["pshy_checkpoints"].commands["gotocheckpoint"] = pshy.commands["gotocheckpoint"]
pshy.perms.cheats["!gotocheckpoint"] = true
--- !setcheckpoint
pshy.commands["setcheckpoint"] = {func = pshy.checkpoints_SetPlayerCheckpoint, desc = "set your checkpoint to the current location", argc_min = 0, argc_max = 0, arg_types = {}}
pshy.help_pages["pshy_checkpoints"].commands["setcheckpoint"] = pshy.commands["setcheckpoint"]
pshy.perms.cheats["!setcheckpoint"] = true
--- !setcheckpoint
pshy.commands["unsetcheckpoint"] = {func = pshy.checkpoints_UnsetPlayerCheckpoint, desc = "delete your checkpoint", argc_min = 0, argc_max = 0, arg_types = {}}
pshy.help_pages["pshy_checkpoints"].commands["unsetcheckpoint"] = pshy.commands["unsetcheckpoint"]
pshy.perms.cheats["!unsetcheckpoint"] = true
--- TFM event eventPlayerWon.
-- temporary fix
function eventPlayerWon(player_name)
	tfm.get.room.playerList[player_name].hasCheese = false
end
--- TFM event eventPlayerDied.
function eventPlayerDied(player_name)
	just_dead_players[player_name] = true
end
--- TFM event eventLoop.
function eventLoop()
	for dead_player in pairs(just_dead_players) do
		if pshy.players[dead_player].checkpoint_x then
			tfm.exec.respawnPlayer(dead_player)
		end
		just_dead_players[dead_player] = false
	end
end
--- TFM event eventPlayerRespawn.
function eventPlayerRespawn(player_name)
	just_dead_players[player_name] = false
	pshy.checkpoints_PlayerCheckpoint(player_name)
end
--- TFM event eventNewGame.
function eventNewGame(player_name)
	if pshy.checkpoints_reset_on_new_game then
		for player_name, player in pairs(pshy.players) do
			player.checkpoint_x = nil
			player.checkpoint_y = nil
			player.checkpoint_hasCheese = nil
		end
	end
	just_dead_players = {}
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_mario_bonuses.lua")
function new_mod.Content()
--- pshy_mario_bonuses.lua
--
-- Mario related bonuses.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
-- @require pshy_bonuses.lua
-- @require pshy_checkpoints.lua
-- @require pshy_imagedb_bonuses.lua
-- @require pshy_players.lua
-- @require pshy_players_keyboard.lua
-- @require pshy_speedfly.lua
--- Module Settings
pshy.mario_powerball_delay = 3000
-- Internal Use:
pshy.players = pshy.players or {}			-- represent the player
--		.mario_coins						-- coint of coins grabbed
--		.mario_grown						-- if the player was grown
--		.mario_flower						-- if the player unlocked powerballs
--		.mario_thrown_powerball_id			-- object id of the thrown powerball
--		.mario_next_powerball_time			-- next time the powerball can be used
--- Touch a player.
-- @TODO: this is probably the wrong place.
local function TouchPlayer(player_name)
	pshy.players[player_name] = pshy.players[player_name] or {}
	local player = pshy.players[player_name]
	player.mario_coins = player.mario_coins or 0
	player.mario_grown = player.mario_grown or false
	player.mario_flower = player.mario_flower or false
	player.powerball_type = tfm.enum.shamanObject.snowBall --tfm.enum.shamanObject.(snowBall powerBall chicken)
	player.mario_thrown_powerball_id = player.mario_thrown_powerball_id or nil
	player.mario_next_powerball_time = player.mario_next_powerball_time or nil
	player.mario_name_color = player.mario_name_color or 0xbbbbbb
	tfm.exec.setNameColor(player_name, player.mario_name_color)
end
--- MarioCoin.
function pshy.bonuses_callback_MarioCoin(player_name, bonus)
	print("mario bonuses: picked")
	local player = pshy.players[player_name]
	player.mario_coins = player.mario_coins + 1
	tfm.exec.setPlayerScore(player_name, 1, true)
	-- update player color
	if player.mario_coins == 9 then
		player.mario_name_color = 0x6688ff -- blue
	elseif player.mario_coins == 25 then
		player.mario_name_color = 0x00eeee -- cyan
	elseif player.mario_coins == 35 then
		player.mario_name_color = 0x77ff77 -- green
	elseif player.mario_coins == 55 then
		player.mario_name_color = 0xeeee00 -- yellow
	elseif player.mario_coins == 75 then
		player.mario_name_color = 0xff7700 -- orange
	elseif player.mario_coins == 100 then
		player.mario_name_color = 0xff0000 -- red
	elseif player.mario_coins == 150 then
		player.mario_name_color = 0xff00bb -- pink
	elseif player.mario_coins == 200 then
		player.mario_name_color = 0xbb00ff -- purple
	else
		return
	end
	tfm.exec.setNameColor(player_name, player.mario_name_color)
end
pshy.bonuses_types["MarioCoin"] = {image = "17aa6f22c53.png", func = pshy.bonuses_callback_MarioCoin}
--- MarioMushroom.
function pshy.bonuses_callback_MarioMushroom(player_name, bonus)
	local player = pshy.players[player_name]
	tfm.exec.changePlayerSize(player_name, 1.4)
	player.mario_grown = true
end
pshy.bonuses_types["MarioMushroom"] = {image = "17c431c5e88.png", func = pshy.bonuses_callback_MarioMushroom}
--- MarioFlower.
function pshy.bonuses_callback_MarioFlower(player_name, bonus)
	local player = pshy.players[player_name]
	tfm.exec.bindKeyboard(player_name, 32, true, true)
	player.mario_flower = true
	player.mario_next_powerball_time = os.time()
	tfm.exec.chatMessage("<ch>Press SPACE to throw a fireball.</ch2>", player_name)
end
pshy.bonuses_types["MarioFlower"] = {image = "17c41851d61.png", func = pshy.bonuses_callback_MarioFlower}
--- MarioCheckpoint.
function pshy.bonuses_callback_MarioCheckpoint(player_name, bonus)
	local player = pshy.players[player_name]
	tfm.exec.bindKeyboard(player_name, 32, true, true)
	player.mario_flower = true
	player.mario_next_powerball_time = os.time()
	tfm.exec.chatMessage("<d>Checkpoint!</d>", player_name)
	pshy.checkpoints_SetPlayerCheckPoint(player_name)
end
-- TODO: bonus image
pshy.bonuses_types["MarioCheckpoint"] = {image = "17bf4c421bb.png", func = pshy.bonuses_callback_MarioCheckpoint, remain = true}
--- TFM event eventKeyboard
-- Handle player teleportations for pipes.
function eventKeyboard(player_name, key_code, down, x, y)
	if key_code == 32 and down then
		local player = pshy.players[player_name]
		if player.mario_flower and player.mario_next_powerball_time + pshy.mario_powerball_delay < os.time() then
			if player.mario_thrown_powerball_id then
				tfm.exec.removeObject(player.mario_thrown_powerball_id)
				player.mario_thrown_powerball_id = nil
			end
			tfm.exec.playEmote(player_name, tfm.enum.emote.highfive_1, nil)
			local speed = player.is_facing_right and 11 or -11
			player.mario_thrown_powerball_id = tfm.exec.addShamanObject(player.powerball_type, x + speed * 2, y, 0, speed, 0, false)
			tfm.exec.displayParticle(tfm.enum.particle.redGlitter, x + speed * 2, y, speed * 0.15, -0.15)
			tfm.exec.displayParticle(tfm.enum.particle.orangeGlitter, x + speed * 2, y, speed * 0.3, 0)
			tfm.exec.displayParticle(tfm.enum.particle.redGlitter, x + speed * 2, y, speed * 0.4, 0)
			tfm.exec.displayParticle(tfm.enum.particle.orangeGlitter, x + speed * 2, y, speed * 0.26, 0.15)
			player.mario_next_powerball_time = os.time()
		end
	end
end
--- TFM event eventPlayerDied.
function eventPlayerDied(player_name)
	local player = pshy.players[player_name]
	if player.mario_grown then
		local death_x = tfm.get.room.playerList[player_name].x
		local death_y = tfm.get.room.playerList[player_name].y
		player.mario_grown = false
		tfm.exec.changePlayerSize(player_name, 1)
		tfm.exec.respawnPlayer(player_name)
		tfm.exec.movePlayer(player_name, death_x, death_y - 30, false)
	end
end
--- Cancel changes the module have made.
local function CancelChanges()
	for player_name, player in pairs(pshy.players) do
		tfm.exec.changePlayerSize(player_name, 1.0)
		player.mario_coins = 0 -- @TODO: do i realy want to reset this ?
		player.mario_grown = false
		player.mario_flower = false -- @TODO: do i realy want to reset this ?
	end
end
--- Pshy event eventGameEnded()
function eventGameEnded()
	CancelChanges()
end
--- TFM event eventnewGame
function eventNewGame()
	for player_name, player in pairs(pshy.players) do
		player.mario_thrown_powerball_id = nil
		player.mario_next_powerball_time = 0
	end
	CancelChanges()
end
--- TFM event eventNewPlayer.
function eventNewPlayer(player_name)
	TouchPlayer(player_name)
end
--- Pshy event eventInit.
function eventInit()
	for player_name in pairs(tfm.get.room.playerList) do
		TouchPlayer(player_name)
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_misc_bonuses.lua")
function new_mod.Content()
--- pshy_misc_bonuses.lua
--
-- Custom bonuses list (advanced list, contains bonuses that dont look like ones).
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
-- @require pshy_checkpoints.lua
-- @require pshy_speedfly.lua
-- @require pshy_bonuses.lua
-- @require pshy_imagedb.lua
--- Internal Use:
local removed_grounds = {}
--- MouseTrap.
-- Same as BonusCheese but with a mouse trap image and a little board, and shared.
function pshy.bonuses_callback_MouseTrap(player_name, bonus)
	tfm.exec.killPlayer(player_name)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, -2, -6.8, 0, 1, nil)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, -1, -7, 0, 1, nil)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, 0, -7.1, 0, 1, nil)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, 1, -7, 0, 1, nil)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, 2, -6.8, 0, 1, nil)
	local obj_id = tfm.exec.addShamanObject(tfm.enum.shamanObject.tinyBoard, bonus.x, bonus.y, angle, 1, -4, false)
	-- TODO: use a mouse trap image:
	pshy.imagedb_AddImage("17bf4b7ddd6.png", "#" .. tostring(obj_id), 0, 0, nil, nil, nil, 0.0, 1.0)
end
pshy.bonuses_types["MouseTrap"] = {image = "17bf4b7a091.png", func = pshy.bonuses_callback_MouseTrap, shared = true}
--- GoreDeath.
-- This bonus is invisible.
-- Cause the mouse to explode into blood.
function pshy.bonuses_callback_GoreDeath(player_name, bonus)
	tfm.exec.movePlayer(player_name, bonus.x, bonus.y + 10000, false, 0, 0, false)
	tfm.exec.killPlayer(player_name)
	local redConfetti = tfm.enum.particle.redConfetti
	local redGlitter = tfm.enum.particle.redGlitter
	local blood_patches = {{-2.5, -4}, {-1, -5}, {0, -7}, {1, -6}, {2.5, -4}, {0.5, -4}, {-1.5, -4.5}}
	local rnx = math.random(0, 100) / 100
	local rny = math.random(0, 100) / 100
	for i_patch, patch in ipairs(blood_patches) do
		tfm.exec.displayParticle(redConfetti, bonus.x + 1, bonus.y + 2, patch[1] + 0.1 + rnx, patch[2] + 0.2 + rny, 0, 0.3, nil)
		tfm.exec.displayParticle(redConfetti, bonus.x + 2, bonus.y + 1, patch[1] + 0.3 + rnx, patch[2] + 0.0 + rny, 0, 0.3, nil)
		tfm.exec.displayParticle(redConfetti, bonus.x + 3, bonus.y + 2, patch[1] + 0.0 + rnx, patch[2] + 0.4 + rny, 0, 0.3, nil)
		tfm.exec.displayParticle(redConfetti, bonus.x + 2, bonus.y + 1, patch[1] + 0.2 + rnx, patch[2] + 0.1 + rny, 0, 0.3, nil)
		tfm.exec.displayParticle(redConfetti, bonus.x + 1, bonus.y + 2, patch[1] + 0.0 + rnx, patch[2] + 0.2 + rny, 0, 0.3, nil)
	end
end
pshy.bonuses_types["GoreDeath"] = {image = nil, func = pshy.bonuses_callback_GoreDeath, remain = true}
--- Cheese.
-- Act like a cheese.
function pshy.bonuses_callback_Cheese(player_name, bonus)
	if tfm.get.room.playerList[player_name].hasCheese then
		return false
	end
	tfm.exec.giveCheese(player_name)
end
pshy.bonuses_types["Cheese"] = {image = "155592fd7d0.png", func = pshy.bonuses_callback_Cheese, remain = true}
--- Hole.
-- Act like an hole.
function pshy.bonuses_callback_Hole(player_name, bonus)
	if not tfm.get.room.playerList[player_name].isDead then
		return false
	end
	tfm.exec.playerVictory(player_name)
end
pshy.bonuses_types["Hole"] = {image = "17cc269a03d.png", func = pshy.bonuses_callback_Hole, remain = true}
--- PickableCheese.
-- If a player take the cheese then others cant pick it.
function pshy.bonuses_callback_PickableCheese(player_name, bonus)
	if tfm.get.room.playerList[player_name].hasCheese then
		return false
	end
	tfm.exec.giveCheese(player_name)
end
pshy.bonuses_types["PickableCheese"] = {image = "155592fd7d0.png", func = pshy.bonuses_callback_PickableCheese, shared = true}
--- CorrectCheese.
-- Like a normal cheeze but congrats the player.
function pshy.bonuses_callback_CorrectCheese(player_name, bonus)
	tfm.exec.giveCheese(player_name)
	--pshy.imagedb_AddImage("155592fd7d0.png", "!0", bonus.x, bonus.y, player_name, nil, nil, 0.0, 1.0)
	pshy.imagedb_AddImage("17bf4f3f2fb.png", "!0", bonus.x, bonus.y, player_name, nil, nil, 0.0, 1.0)
end
pshy.bonuses_types["CorrectCheese"] = {image = "155592fd7d0.png", func = pshy.bonuses_callback_CorrectCheese}
--- WrongCheese.
-- Like a normal cheeze but kills the player.
function pshy.bonuses_callback_WrongCheese(player_name, bonus)
	tfm.exec.killPlayer(player_name)
	--pshy.imagedb_AddImage("155593003fc.png", "!0", bonus.x, bonus.y, player_name, nil, nil, 0.0, 1.0)
	pshy.imagedb_AddImage("17bf4b89eba.png", "!0", bonus.x, bonus.y, player_name, nil, nil, 0.0, 1.0)
end
pshy.bonuses_types["WrongCheese"] = {image = "155592fd7d0.png", func = pshy.bonuses_callback_WrongCheese}
--- BonusRemoveGround.
-- If the mouse grabs it, then a specific ground disapear.
function pshy.bonuses_callback_BonusCircle(player_name, bonus)
	if type(bonus.remove_ground_id) == "number" then
		tfm.exec.removePhysicObject(bonus.remove_ground_id)
	else
		for i_id, id in ipairs(bonus.remove_ground_id) do
			tfm.exec.removePhysicObject(id)
			table.insert(removed_grounds, id)
		end
	end
end
pshy.bonuses_types["BonusRemoveGround"] = {image = "17bef4f49c5.png", func = pshy.bonuses_callback_BonusCircle, shared = true}
function eventNewGame()
	removed_grounds = {}
end
function eventNewPlayer(player_name)
	for i_removed_ground, removed_ground in ipairs(removed_grounds) do
		tfm.exec.removePhysicObject(removed_ground)
	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_basic_bonuses.lua")
function new_mod.Content()
--- pshy_basic_bonuses.lua
--
-- Custom bonuses list.
--
-- @author TFM:Pshy#3752 DC:Pshy#7998
-- @require pshy_checkpoints.lua
-- @require pshy_speedfly.lua
-- @require pshy_bonuses.lua
-- @require pshy_imagedb_bonuses.lua
-- @require pshy_mario_bonuses.lua
-- @require pshy_misc_bonuses.lua
-- Transformations, Free link, explosion, grow, shrink, shaman, vampire, balloon, snowflake, turn into cheese, checkpoint, heart/broken heart, fly, speed, loose-cheeze
-- cross, teleporter, mousetrap
--- Internal Use:
local changed_sizes = {}
local last_heart_grabber = nil
local linked_mice = {}
local transformices = {}
local strange_players = false
local spawnpoints = {}
--- BonusShrink.
function pshy.bonuses_callback_BonusShrink(player_name, bonus)
	local new_size = bonus.scale or 0.5
	tfm.exec.changePlayerSize(player_name, new_size)
	changed_sizes[player_name] = new_size
end
pshy.bonuses_types["BonusShrink"] = {image = "17bf4b63aaa.png", func = pshy.bonuses_callback_BonusShrink}
--- BonusGrow.
function pshy.bonuses_callback_BonusGrow(player_name, bonus)
	local new_size = bonus.scale or 1.8
	tfm.exec.changePlayerSize(player_name, new_size)
	changed_sizes[player_name] = new_size
end
pshy.bonuses_types["BonusGrow"] = {image = "17bf4b67579.png", func = pshy.bonuses_callback_BonusGrow}
--- BonusAttachBalloon.
-- Attack a balloon to the player.
-- bonus.ghost: is the balloon ghosted.
function pshy.bonuses_callback_BonusAttachBalloon(player_name, bonus)
	tfm.exec.attachBalloon(player_name, true)
end
pshy.bonuses_types["BonusAttachBalloon"] = {image = "17bf4b80fc3.png", func = pshy.bonuses_callback_BonusAttachBalloon}
--- BonusFly.
function pshy.bonuses_callback_BonusFly(player_name, bonus)
	pshy.speedfly_Fly(player_name, 50)
end
pshy.bonuses_types["BonusFly"] = {image = "17bf4b7250e.png", func = pshy.bonuses_callback_BonusFly}
--- BonusHighSpeed.
function pshy.bonuses_callback_BonusHighSpeed(player_name, bonus)
	pshy.speedfly_Speed(player_name, 200)
end
pshy.bonuses_types["BonusHighSpeed"] = {image = "17bf4b9af56.png", func = pshy.bonuses_callback_BonusHighSpeed}
--- BonusShaman.
-- Turn the first player to grab it into shaman.
function pshy.bonuses_callback_BonusShaman(player_name, bonus)
	tfm.exec.setShaman(player_name, true)
end
pshy.bonuses_types["BonusShaman"] = {image = "17bf4b8c42d.png", func = pshy.bonuses_callback_BonusShaman, shared = true}
--- BonusTransformations.
function pshy.bonuses_callback_BonusTransformations(player_name, bonus)
	tfm.exec.giveTransformations(player_name, true)
	transformices[player_name] = true
end
pshy.bonuses_types["BonusTransformations"] = {image = "17bf4b6f226.png", func = pshy.bonuses_callback_BonusTransformations}
--- BonusFreeze.
-- Freeze the picker.
function pshy.bonuses_callback_BonusFreeze(player_name, bonus)
	tfm.exec.freezePlayer(player_name, true)
end
pshy.bonuses_types["BonusFreeze"] = {image = "17bf4b94d8a.png", func = pshy.bonuses_callback_BonusFreeze}
--- BonusIce.
-- Turn the player into an ice block.
function pshy.bonuses_callback_BonusIce(player_name, bonus)
	local tfm_player = tfm.get.room.playerList[player_name]
	local speed_x = tfm_player.vx
	local speed_y = tfm_player.vy
	tfm.exec.killPlayer(player_name)
	local obj_id = tfm.exec.addShamanObject(tfm.enum.shamanObject.iceCube, bonus.x, bonus.y, angle, speed_x, speed_y, false)
end
pshy.bonuses_types["BonusIce"] = {image = "17bf4b977f5.png", func = pshy.bonuses_callback_BonusIce}
--- BonusStrange.
function pshy.bonuses_callback_BonusStrange(player_name, bonus)
	tfm.exec.setVampirePlayer(player_name, true)
	pshy.imagedb_AddImageMin("17bf4b75aa7.png", "%" .. player_name, 0, 0, nil, 30, 30, 0, 1.0)
	strange_players = true
end
pshy.bonuses_types["BonusStrange"] = {image = "17bf4b75aa7.png", func = pshy.bonuses_callback_BonusStrange}
--- BonusCheese.
-- Turn the player into a cheese.
function pshy.bonuses_callback_BonusCheese(player_name, bonus)
	tfm.exec.killPlayer(player_name)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, -2, -6.8, 0, 1, nil)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, -1, -7, 0, 1, nil)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, 0, -7.1, 0, 1, nil)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, 1, -7, 0, 1, nil)
	tfm.exec.displayParticle(tfm.enum.particle.yellowGlitter, bonus.x, bonus.y, 2, -6.8, 0, 1, nil)
	local tfm_player = tfm.get.room.playerList[player_name]
	local speed_x = tfm_player.vx
	local speed_y = tfm_player.vy
	local obj_id = tfm.exec.addShamanObject(tfm.enum.shamanObject.littleBox, bonus.x, bonus.y, angle, speed_x, speed_y, false)
	pshy.imagedb_AddImage("155592fd7d0.png", "#" .. tostring(obj_id), 0, 0, nil, nil, nil, 0.0, 1.0)
end
pshy.bonuses_types["BonusCheese"] = {image = "17bf4b6b157.png", func = pshy.bonuses_callback_BonusCheese}
--- BonusCheckpoint.
-- Checkpoint the player (if the checkpoint module is available).
function pshy.bonuses_callback_BonusCheckpoint(player_name, bonus)
	pshy.checkpoints_SetPlayerCheckpoint(player_name, bonus.x, bonus.y)
	tfm.exec.chatMessage("<d>Checkpoint!</d>", player_name)
end
pshy.bonuses_types["BonusCheckpoint"] = {image = "17e59dbef1e.png", func = pshy.bonuses_callback_BonusCheckpoint}
--- BonusSpawnpoint.
-- Set a player's spawn point.
-- As soon as the player have a spawnpoint, they also will keep the cheese.
function pshy.bonuses_callback_BonusSpawnpoint(player_name, bonus)
	local tfm_player = tfm.get.room.playerList[player_name]
	spawnpoints[player_name] = {x = bonus.x, y = bonus.y, has_cheese = tfm_player.hasCheese}
	tfm.exec.chatMessage("<d>Spawnpoint set!</d>", player_name)
end
pshy.bonuses_types["BonusSpawnpoint"] = {image = "17bf4c421bb.png", func = pshy.bonuses_callback_BonusSpawnpoint}
--- BonusTeleporter.
-- bonus.dst: tp coordinates (or random). Should be a table with `x` and `y`, or a list of random destinations.
function pshy.bonuses_callback_BonusTeleporter(player_name, bonus)
	local dst_x, dst_y
	if bonus.dst and bonus.dst[1] then
		local random_dst = bonus.dst[math.random(1, #bonus.dst)]
		dst_x = random_dst.x
		dst_y = random_dst.y
	else
		dst_x = bonus.dst and bonus.dst.x or (400 + math.random(-400, 400))
		dst_y = bonus.dst and bonus.dst.y or (200 + math.random(-200, 200))
	end
	tfm.exec.displayParticle(tfm.enum.particle.mouseTeleportation, bonus.x, bonus.y, 0, 0, 0, 0, nil)
	tfm.exec.movePlayer(player_name, dst_x, dst_y)
	tfm.exec.displayParticle(tfm.enum.particle.mouseTeleportation, dst_x, dst_y, 0, 0, 0, 0, nil)
end
pshy.bonuses_types["BonusTeleporter"] = {image = "17bf4ba4ce5.png", func = pshy.bonuses_callback_BonusTeleporter}
pshy.bonuses_types["Teleporter"] = {image = "17bf4ba4ce5.png", func = pshy.bonuses_callback_BonusTeleporter, remain = true}
--- BonusCircle.
-- If the mouse grabs it, then it become the bonus.
function pshy.bonuses_callback_BonusCircle(player_name, bonus)
	tfm.exec.killPlayer(player_name)
	pshy.imagedb_AddImage("17bf4b868c3.png", "!0", bonus.x, bonus.y, player_name, nil, nil, 0.0, 1.0)
end
pshy.bonuses_types["BonusCircle"] = {image = "17bef4f49c5.png", func = pshy.bonuses_callback_BonusCircle}
--- BonusMarry.
function pshy.bonuses_callback_BonusMarry(player_name, bonus)
	if last_heart_grabber == nil then
		last_heart_grabber = player_name
	elseif last_heart_grabber ~= player_name then
		tfm.exec.linkMice(player_name, last_heart_grabber, true)
		table.insert(linked_mice, {player_name, last_heart_grabber})
		last_heart_grabber = nil
	end
end
pshy.bonuses_types["BonusMarry"] = {image = "17bf4b8f9e4.png", func = pshy.bonuses_callback_BonusMarry}
--- BonusDivorce.
-- Remove any soulmate link this mouse has.
function pshy.bonuses_callback_BonusDivorce(player_name, bonus)
	tfm.exec.linkMice(player_name, player_name, true)
	tfm.exec.linkMice(player_name, player_name, false)
	if last_heart_grabber == player_name then
		last_heart_grabber = nil
	end
end
pshy.bonuses_types["BonusDivorce"] = {image = "17bf4b91c35.png", func = pshy.bonuses_callback_BonusDivorce}
--- BonusCannonball.
-- Shoot a cannonball at the player.
function pshy.bonuses_callback_BonusCannonball(player_name, bonus)
	local tfm_player = tfm.get.room.playerList[player_name]
	local angle = (bonus.angle or 0)
	local speed_x = math.cos((angle * math.pi * 2.0 / 360.0) - math.pi / 2) * 20
	local speed_y = math.sin((angle * math.pi * 2.0 / 360.0) - math.pi / 2) * 20
	local obj_id = tfm.exec.addShamanObject(tfm.enum.shamanObject.cannon, bonus.x - speed_x * 10, bonus.y - speed_y * 10 - 10, angle, speed_x, speed_y, false)
end
pshy.bonuses_types["BonusCannonball"] = {image = "17e53fb43dc.png", func = pshy.bonuses_callback_BonusCannonball, shared = true}
--- BonusFish.
-- Summon a load of fishes.
function pshy.bonuses_callback_BonusFish(player_name, bonus)
	for i = 1, 40 do
		tfm.exec.addShamanObject(tfm.enum.shamanObject.fish, bonus.x + i % 3, bonus.y - i, 0)
	end
end
pshy.bonuses_types["BonusFish"] = {image = "17e59ba43a6.png", func = pshy.bonuses_callback_BonusFish, shared = true}
--- BonusDeath.
-- Summon a load of fishes.
function pshy.bonuses_callback_BonusDeath(player_name, bonus)
	tfm.exec.killPlayer(player_name)
end
pshy.bonuses_types["BonusDeath"] = {image = "17ebfdb85bd.png", func = pshy.bonuses_callback_BonusDeath, remain = true}
function eventPlayerDied(player_name)
	if spawnpoints[player_name] then
		tfm.exec.respawnPlayer(player_name)
	end
end
function eventPlayerGetCheese(player_name)
	if spawnpoints[player_name] then
		spawnpoints[player_name].has_cheese = true
	end
end
--- TFM event eventPlayerRespawn.
function eventPlayerRespawn(player_name)
	if changed_sizes[player_name] then
		tfm.exec.changePlayerSize(player_name, 1.0)
		changed_sizes[player_name] = nil
	end
	if spawnpoints[player_name] then
		local spawn = spawnpoints[player_name]
		tfm.exec.movePlayer(player_name, spawn.x, spawn.y, false, -1, -1, false)
		if spawn.has_cheese then
			tfm.exec.giveCheese(player_name)
		end
	end
end
--- TFM event eventPlayerVampire.
function eventPlayerVampire(player_name)
	if strange_players then
		pshy.bonuses_callback_BonusStrange(player_name, nil)
	end
end
--- Cancel changes the module have made.
local function CancelChanges()
	for player_name in pairs(changed_sizes) do
		tfm.exec.changePlayerSize(player_name, 1.0)
	end
	changed_sizes = {}
	for i_link, pair in pairs(linked_mice) do
		tfm.exec.linkMice(pair[1], pair[2], false)
	end
	linked_mice = {}
	last_heart_grabber = nil
	for player_name in pairs(transformices) do
		tfm.exec.giveTransformations(player_name, false)
	end
	transformices = {}
end
--- Pshy event eventGameEnded()
function eventGameEnded()
	CancelChanges()
end
--- TFM event eventnewGame
function eventNewGame()
	CancelChanges()
	strange_players = false
	spawnpoints = {}
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
local new_mod = pshy.merge_ModuleBegin("pshy_mapdb_chickengame.lua")
function new_mod.Content()
	local __IS_MAIN_MODULE__ = true
--- pshy_mapdb_chickengame.lua
--
-- Additional maps for Nnaaaz's currently not named minigame.
--
-- @author: TFM:Pshy#3752 DC:Pshy#7998
--
-- @require pshy_basic_bonuses.lua
-- @require pshy_mapdb.lua
-- @require pshy_newgame.lua
--
-- TEMPORARY REQUIRE (waiting for a fix about the sync bug):
-- @requirepshy_commands_rp.lua
--- Internal Use:
local tabinsert = table.insert
--- Maps:
local maps = {}
--map 1
pshy.mapdb_maps["1"] = {author = "<b><ch> Intro </ch></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="400" Y="275" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="399" Y="71" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="399" Y="181" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="399" Y="181" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="1"/><S T="12" X="371" Y="255" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="429" Y="255" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="400" Y="275" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="399" Y="256" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="399" Y="181" L="20" P="1,0,0.3,0,0,1,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="401" Y="230" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="7" M2="6"/><JR M1="7" M2="8"/><JR M1="8" M2="15"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "1")
pshy.mapdb_maps["1"].bonuses = {
	{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1}};
}
--map 2
pshy.mapdb_maps["2"] = {author = "<b><vp> Easy </vp></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" /><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="400" Y="310" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="508" Y="93" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="285" Y="92" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="401" Y="52" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="401" Y="205" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4"/><S T="13" X="401" Y="205" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="401" Y="205" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="1"/><S T="13" X="401" Y="205" L="10" P="1,0,0.3,0.2,-10,0,1,0" c="4" lua="2"/><S T="13" X="401" Y="205" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="401" Y="205" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="3"/><S T="12" X="371" Y="290" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="429" Y="290" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="400" Y="310" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="399" Y="291" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="401" Y="205" L="20" P="1,0,0.3,0,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="401" Y="265" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="13" M2="6"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="10" M2="7"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="9" M2="8"/><JR M1="10" M2="11"/><JR M1="13" M2="14"/><JR M1="9" M2="12"/><JR M1="11" M2="21"/><JR M1="12" M2="21"/><JR M1="14" M2="21"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "2")
pshy.mapdb_maps["2"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
}

--map 3
pshy.mapdb_maps["3"] = {author = "<b><vp> Easy </vp></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="106" Y="466" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="15" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="106" Y="499" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="106" Y="440" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="370" Y="313" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="493" Y="47" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="270" Y="62" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="511" Y="249" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="341" Y="293" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="399" Y="293" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="370" Y="313" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="369" Y="294" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="503" Y="122" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="384"/><T X="767" Y="391"/><DS X="400" Y="375"/></D><O><O X="370" Y="270" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="9" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="11" M2="8"/><JR M1="13" M2="10"/><JR M1="10" M2="21"/><JR M1="9" M2="12"/><JR M1="12" M2="21"/><JR M1="11" M2="14"/><JR M1="14" M2="21"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "3")
pshy.mapdb_maps["3"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
}
--map 4
pshy.mapdb_maps["4"] = {author = "<b><vp> Easy </vp></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="106" Y="456" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="15" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="106" Y="489" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="106" Y="430" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="190" Y="293" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="493" Y="47" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" i="-13,-12,17ea2bfde60.png"/><S T="13" X="80" Y="42" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" i="-14,-12,17ea2befa39.png"/><S T="13" X="311" Y="49" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" i="-14,-12,17ea2bf9260.png"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="122" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="161" Y="273" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="219" Y="273" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="190" Y="293" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="189" Y="274" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="503" Y="122" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="384"/><T X="767" Y="391"/><DS X="400" Y="375"/></D><O><O X="190" Y="241" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="9" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="11" M2="8"/><JR M1="13" M2="10"/><JR M1="10" M2="21"/><JR M1="9" M2="12"/><JR M1="12" M2="21"/><JR M1="11" M2="14"/><JR M1="14" M2="21"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "4")
pshy.mapdb_maps["4"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
}

--map 5
pshy.mapdb_maps["5"] = {author = "<b><vp> Easy </vp></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="46" Y="456" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="15" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="46" Y="489" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="46" Y="430" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="252" Y="155" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="391" Y="106" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="680" Y="52" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="81" Y="199" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="523" Y="142" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="523" Y="142" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="523" Y="142" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="523" Y="142" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="523" Y="142" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="523" Y="142" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="223" Y="135" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="281" Y="135" L="10" H="35" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="252" Y="155" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="2" X="329" Y="239" L="10" H="46" P="0,0,0,6,-20,0,0,0"/><S T="12" X="252" Y="136" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="523" Y="142" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="384"/><T X="767" Y="391"/><DS X="400" Y="375"/></D><O><O X="253" Y="110" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="9" M2="6"/><JD c="584141,3,1,0" AMP="1" HZ="1" M1="13" M2="7"/><JD c="584141,3,1,0" AMP="1" HZ="1" M1="11" M2="8"/><JR M1="13" M2="10"/><JR M1="10" M2="22"/><JR M1="9" M2="12"/><JR M1="12" M2="22"/><JR M1="11" M2="14"/><JR M1="14" M2="22"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "5")
pshy.mapdb_maps["5"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
}

--map 6
pshy.mapdb_maps["6"] = {author = "<b><vp> Easy </vp></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="66" Y="456" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="15" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="66" Y="489" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="66" Y="430" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="162" Y="265" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="491" Y="39" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="280" Y="32" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="351" Y="39" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="503" Y="132" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="132" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="503" Y="132" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="132" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="503" Y="132" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="503" Y="132" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="133" Y="245" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="191" Y="245" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="162" Y="265" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="162" Y="246" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="503" Y="132" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="384"/><T X="767" Y="391"/><DS X="400" Y="375"/></D><O><O X="163" Y="220" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="9" M2="6"/><JD c="584141,3,1,0" AMP="1" HZ="1" M1="13" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="11" M2="8"/><JR M1="13" M2="10"/><JR M1="10" M2="21"/><JR M1="9" M2="12"/><JR M1="12" M2="21"/><JR M1="11" M2="14"/><JR M1="14" M2="21"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "6")
pshy.mapdb_maps["6"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
}

--map 7
pshy.mapdb_maps["7"] = {author = "<b><vp> Easy </vp></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="585" Y="294" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="265" Y="251" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="256" Y="47" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="562" Y="50" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="523" Y="257" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="410" Y="141" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="410" Y="141" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="410" Y="141" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="4"/><S T="13" X="410" Y="141" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="410" Y="141" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="410" Y="141" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="410" Y="141" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="410" Y="141" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="556" Y="274" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="614" Y="274" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="585" Y="294" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="584" Y="275" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="410" Y="141" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="586" Y="249" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="15" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="16" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="9"/><JR M1="15" M2="11"/><JR M1="16" M2="12"/><JR M1="10" M2="14"/><JR M1="13" M2="17"/><JR M1="12" M2="24"/><JR M1="11" M2="24"/><JR M1="14" M2="24"/><JR M1="17" M2="24"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "7")
pshy.mapdb_maps["7"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 8
pshy.mapdb_maps["8"] = {author = "<b><vp> Easy </vp></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="585" Y="294" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="139" Y="219" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="92" Y="53" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="505" Y="52" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="523" Y="257" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="333" Y="60" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="333" Y="60" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="333" Y="60" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="4"/><S T="13" X="333" Y="60" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="333" Y="60" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="333" Y="60" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="333" Y="60" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="333" Y="60" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="556" Y="274" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="614" Y="274" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="585" Y="294" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="15" X="290" Y="155" L="137" H="30" P="0,0,0,0,0,0,0,0"/><S T="15" X="452" Y="90" L="140" H="30" P="0,0,0,0,-90,0,0,0"/><S T="12" X="583" Y="275" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="333" Y="60" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="586" Y="249" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="10" M2="6"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="15" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="16" M2="8"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="13" M2="9"/><JR M1="15" M2="11"/><JR M1="16" M2="12"/><JR M1="10" M2="14"/><JR M1="13" M2="17"/><JR M1="12" M2="26"/><JR M1="11" M2="26"/><JR M1="14" M2="26"/><JR M1="17" M2="26"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "8")
pshy.mapdb_maps["8"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 9
pshy.mapdb_maps["9"] = {author = "<b><o> Medium </o></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;19,1;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="381" Y="291" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="381" Y="59" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="10" Y="142" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="351" Y="39" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="341" Y="164" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="54" Y="83" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="146" Y="127" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="341" Y="164" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="54" Y="83" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="146" Y="127" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="352" Y="271" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="410" Y="271" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="381" Y="291" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="50" Y="111" L="100" H="10" P="0,0,0.3,0.2,10,0,0,0" o="292020"/><S T="12" X="241" Y="146" L="100" H="10" P="0,0,0.3,0.2,10,0,0,0" o="292020"/><S T="12" X="437" Y="182" L="100" H="10" P="0,0,0.3,0.2,10,0,0,0" o="292020"/><S T="12" X="146" Y="128" L="90" H="10" P="1,0,0.3,0.2,10,0,0,0" o="433636"/><S T="12" X="340" Y="164" L="90" H="10" P="1,0,0.3,0.2,10,0,0,0" o="433636"/><S T="12" X="380" Y="272" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="54" Y="83" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="382" Y="246" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="9" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="11" M2="8"/><JR M1="13" M2="10"/><JR M1="10" M2="26"/><JR M1="9" M2="12"/><JR M1="12" M2="24"/><JR M1="11" M2="14"/><JR M1="14" M2="23"/><JR M1="23" P1="100.95,118.81"/><JR M1="24" P1="294.28,154.37"/><JD c="ffd78a,5,1,1" P1="105.4,120.55" P2="105.4,121.55"/><JD c="ffd78a,5,1,1" P1="299.84,157.22" P2="299.84,158.22"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "9")
pshy.mapdb_maps["9"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
}

--map 10
pshy.mapdb_maps["10"] = {author = "<b><o> Medium </o></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;19,1;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="111" Y="291" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="741" Y="149" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="740" Y="42" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="181" Y="31" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="704" Y="94" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="550" Y="234" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="86" Y="159" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="704" Y="94" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="550" Y="234" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="86" Y="159" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="82" Y="271" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="140" Y="271" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="111" Y="291" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="700" Y="121" L="100" H="10" P="0,0,0.3,0.2,-10,0,0,0" o="292020"/><S T="12" X="653" Y="253" L="100" H="10" P="0,0,0.3,0.2,10,0,0,0" o="292020"/><S T="12" X="86" Y="160" L="90" H="10" P="1,0,20,0,0,0,0,0" o="433636"/><S T="12" X="550" Y="234" L="90" H="10" P="1,0,0.3,0.2,10,0,0,0" o="433636"/><S T="3" X="702" Y="226" L="10" H="50" P="0,0,0,8,10,0,0,0"/><S T="12" X="110" Y="273" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="704" Y="94" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="112" Y="246" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="9" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="11" M2="8"/><JR M1="13" M2="10"/><JR M1="10" M2="23"/><JR M1="9" M2="12"/><JR M1="12" M2="26"/><JR M1="11" M2="14"/><JR M1="14" M2="22"/><JR M1="22" P1="42.06,159.92" LIM1="-1.5707963267948966" LIM2="Infinity"/><JR M1="23" P1="507.9,226.65"/><JD c="ffd78a,5,1,1" P1="509.33,226.77" P2="509.33,227.77"/><JD c="ffd78a,5,1,1" P1="44.5,159.79" P2="44.5,160.79"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "10")
pshy.mapdb_maps["10"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
}
--map 11
pshy.mapdb_maps["11"] = {author = "<b><o> Medium </o></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="739" Y="363" L="58" H="10" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="332" Y="314" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="12" X="179" Y="449" L="20" H="20" P="1,1000000000000,0.3,0.2,0,1,0,0"/><S T="12" X="731" Y="363" L="58" H="10" P="1,1000000,0,0,-270,1,0,0" o="BC0C0C"/><S T="12" X="179" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0"/><S T="12" X="179" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0"/><S T="12" X="646" Y="274" L="35" H="10" P="1,0,20,0,0,1,0,0"/><S T="13" X="25" Y="89" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="429" Y="147" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4"/><S T="13" X="331" Y="147" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="131" Y="88" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="331" Y="71" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="429" Y="147" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4" lua="2"/><S T="13" X="331" Y="147" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="3"/><S T="13" X="131" Y="88" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="4"/><S T="13" X="24" Y="32" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="129" Y="35" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="429" Y="73" L="10" P="0,0,0.3,0.2,0,0,0,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="12" X="303" Y="294" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20" c="2"/><S T="12" X="618" Y="256" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="361" Y="294" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20" c="2"/><S T="12" X="676" Y="256" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="332" Y="314" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="4"/><S T="12" X="647" Y="275" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="331" Y="295" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="12" X="646" Y="257" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="72" Y="63" L="20" P="1,0,0.3,0,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/><S T="13" X="376" Y="122" L="20" P="1,0,0.3,0,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/><S T="13" X="25" Y="89" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="1"/><S T="12" X="210" Y="135" L="180" H="45" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="504" Y="193" L="180" H="45" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="78" Y="88" L="110" H="12" P="1,0,0.3,0.2,0,0,0,0" o="583B29" c="2"/><S T="12" X="382" Y="148" L="110" H="12" P="1,0,0.3,0.2,0,0,0,0" o="583B29" c="2"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="333" Y="269" C="0" P="0"/><O X="648" Y="231" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JR M1="6"/><JP M1="7" AXIS="0,1"/><JR M1="7" M2="6"/><JP M1="8" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="8" M2="7"/><JP M1="10" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="10" M2="9"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="15"/><JD c="584141,3,1,0" AMP="1" M1="11" M2="19"/><JD c="584141,3,1,0" AMP="1" M1="14" M2="20"/><JD c="584141,3,1,0" AMP="1" M1="12" M2="21"/><JR M1="11" M2="34"/><JR M1="14" M2="18"/><JR M1="13" M2="17"/><JR M1="12" M2="16"/><JR M1="34" M2="37" LIM1="0" LIM2="0"/><JR M1="18" M2="37" LIM1="0" LIM2="0"/><JR M1="17" M2="38" LIM1="0" LIM2="0"/><JR M1="16" M2="38" LIM1="0" LIM2="0"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "11")
pshy.mapdb_maps["11"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 12
pshy.mapdb_maps["12"] = {author = "<b><o> Medium </o></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="341" Y="221" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="51" Y="29" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="40" Y="222" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="780" Y="142" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="691" Y="231" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="54" Y="94" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="45" Y="286" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="770" Y="326" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="4"/><S T="13" X="775" Y="30" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="54" Y="94" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="45" Y="286" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="770" Y="326" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="775" Y="30" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="312" Y="201" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="370" Y="201" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="341" Y="221" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="665" Y="150" L="122" H="10" P="0,0,0.3,0.2,-20,0,0,0" o="292020"/><S T="12" X="507" Y="171" L="204" H="10" P="0,0,1,0.2,0,0,0,0" o="292020"/><S T="12" X="46" Y="286" L="71" H="10" P="1,0,0.3,0,0,1,0,0" o="292020" lua="4444"/><S T="12" X="770" Y="326" L="71" H="10" P="1,0,0.3,0,0,1,0,0" o="292020"/><S T="12" X="9" Y="276" L="30" H="10" P="1,0,0.3,0,-90,1,0,0" o="292020" lua="44"/><S T="12" X="733" Y="316" L="30" H="10" P="1,0,0.3,0,-90,1,0,0" o="292020" lua="22"/><S T="12" X="80" Y="276" L="30" H="10" P="1,0,0.3,0,-90,1,0,0" o="292020" lua="444"/><S T="12" X="804" Y="316" L="30" H="10" P="1,0,0.3,0,-90,1,0,0" o="292020" lua="222"/><S T="12" X="776" Y="30" L="90" H="10" P="1,0,0.3,0.2,0,0,0,0" o="433636"/><S T="12" X="339" Y="204" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="54" Y="94" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="342" Y="176" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="15" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="16" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="9"/><JR M1="15" M2="11"/><JR M1="16" M2="12"/><JR M1="10" M2="14"/><JR M1="14" M2="33"/><JR M1="13" M2="17"/><JR M1="31" P1="733.61,30.5" LIM1="-1.5707963267948966" LIM2="Infinity"/><JR M1="25" M2="27"/><JR M1="26" M2="28"/><JP M1="25" AXIS="-1,0" LIM1="-1.5" LIM2="24.1" MV="1000,1.6666666666666667"/><JR M1="11" M2="25"/><JR M1="25" M2="29"/><JR M1="26" M2="30"/><JR M1="12" M2="26"/><JP M1="26" AXIS="0,1" LIM1="0" LIM2="6.833333333333333" MV="1000,1.6666666666666667"/><JR M1="17" M2="31"/><JD c="000000,3,1,1" P1="33,302" P2="39,306"/><JD c="000000,3,1,1" P1="707.27,322.09" P2="711.27,316.09"/><JD c="000000,3,1,1" P1="43,302" P2="49,306"/><JD c="000000,3,1,1" P1="707.27,312.09" P2="711.27,306.09"/><JD c="000000,3,1,1" P1="33,310" P2="39,306"/><JD c="000000,3,1,1" P1="715.27,322.09" P2="711.27,316.09"/><JD c="000000,3,1,1" P1="43,310" P2="49,306"/><JD c="000000,3,1,1" P1="715.27,312.09" P2="711.27,306.09"/><JD c="ffd78a,5,1,1" P1="733.74,30.6" P2="733.74,31.6"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "12")
pshy.mapdb_maps["12"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 13
pshy.mapdb_maps["13"] = {author = "<b><o> Medium </o></b>", shamans = 0, autoskip = false, xml = [[<C><P MEDATA=";;;30,1;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="601" Y="316" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="454" Y="49" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="273" Y="202" L="10" P="1,300,0.3,0.2,0,1,0,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="530" Y="142" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="361" Y="101" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="454" Y="174" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="275" Y="266" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="273" Y="202" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="4"/><S T="13" X="575" Y="40" L="10" P="1,0,0.3,0.2,0,1,0,0" c="4"/><S T="13" X="454" Y="174" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="275" Y="266" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="273" Y="202" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="575" Y="40" L="10" P="1,0,0.3,0.2,10,1,0,0" c="4" lua="2"/><S T="12" X="572" Y="296" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="630" Y="296" L="10" H="35" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="601" Y="316" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="275" Y="266" L="71" H="10" P="1,0,0.3,0,0,1,1,0" o="292020" lua="111"/><S T="12" X="239" Y="256" L="30" H="10" P="1,0,0.3,0,-90,1,1,0" o="292020" lua="11"/><S T="12" X="310" Y="256" L="30" H="10" P="1,0,0.3,0,-90,1,1,0" o="292020" lua="1111"/><S T="12" X="600" Y="40" L="140" H="10" P="1,0,0.3,0.2,0,0,0,0" o="433636"/><S T="13" X="664" Y="40" L="23" P="1,0,0.3,0.2,0,0,0,0" o="433636"/><S T="12" X="435" Y="209" L="16" H="10" P="0,0,0,0,-130,0,0,0" o="292020"/><S T="12" X="475" Y="209" L="16" H="10" P="0,0,0,0,130,0,0,0" o="292020"/><S T="12" X="600" Y="298" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="454" Y="174" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="602" Y="271" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="15" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="16" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="9"/><JR M1="15" M2="11"/><JR M1="16" M2="12"/><JR M1="10" M2="14"/><JR M1="14" M2="31"/><JR M1="13" M2="17"/><JR M1="26" P1="532.89,40.54" LIM1="-2.0943951023931953" LIM2="Infinity"/><JR M1="23" M2="24"/><JP M1="7" AXIS="-1,0" LIM1="0" LIM2="18.947156803165726" MV="1000,1.6666666666666667"/><JR M1="11" M2="23"/><JR M1="23" M2="25"/><JR M1="12" M2="7"/><JR M1="17" M2="26"/><JD c="000000,3,1,1" P1="263,282" P2="269,286"/><JD c="000000,3,1,1" P1="273,282" P2="279,286"/><JD c="000000,3,1,1" P1="263,290" P2="269,286"/><JD c="000000,3,1,1" P1="273,290" P2="279,286"/><JR M1="27" M2="26" LIM1="0" LIM2="0"/><JR M1="17" M2="13"/><JR M1="24" M2="25"/><JD c="ffd78a,5,1,1" P1="534.89,39.58" P2="534.89,40.58"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "13")
pshy.mapdb_maps["13"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 14
pshy.mapdb_maps["14"] = {author = "<b><o> Medium </o></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="672" Y="311" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="390" Y="64" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="250" Y="178" L="10" P="1,0,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="310" Y="35" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="253" Y="334" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="-160" Y="62" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="254" Y="273" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="569" Y="195" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="4"/><S T="13" X="254" Y="273" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="-160" Y="62" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="254" Y="273" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="569" Y="195" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="254" Y="273" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="643" Y="291" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="701" Y="291" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="672" Y="311" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="32" Y="41" L="56" H="10" P="1,0,0.3,0.2,0,1,0,0" o="292020"/><S T="12" X="56" Y="55" L="38" H="10" P="1,0,0.3,0.2,90,1,0,0" o="292020"/><S T="12" X="0" Y="55" L="38" H="10" P="1,0,0.3,0.2,-90,1,0,0" o="292020"/><S T="12" X="-160" Y="62" L="320" H="24" P="1,0,0,0,0,1,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="569" Y="195" L="88" H="10" P="1,0,0.3,0,-20,0,0,0" o="292020"/><S T="12" X="671" Y="293" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="252" Y="275" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="673" Y="266" C="0" P="0"/><O X="250" Y="178" C="59" P="0"/><O X="250" Y="178" C="22" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="15" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="16" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="9"/><JR M1="15" M2="11"/><JR M1="16" M2="12"/><JR M1="10" M2="14"/><JR M1="13" M2="17"/><JR M1="11" M2="29"/><JR M1="14" M2="25"/><JR M1="17" M2="29"/><JR M1="25" M2="24"/><JR M1="25" M2="22"/><JR M1="25" M2="23"/><JR M2="27" P1="531.01,208.53" LIM1="-Infinity" LIM2="0.7853981633974483"/><JR M1="12" M2="27"/><JP M1="25" AXIS="-1,0" LIM1="0" LIM2="17.5" MV="1000,1.6666666666666667"/><JD c="000000,3,1,1" P1="21,101" P2="27,105"/><JD c="000000,3,1,1" P1="31,101" P2="37,105"/><JD c="000000,3,1,1" P1="21,109" P2="27,105"/><JD c="000000,3,1,1" P1="31,109" P2="37,105"/><JD c="ffd78a,5,1,1" P1="531.25,208.26" P2="531.25,209.26"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "14")
pshy.mapdb_maps["14"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 15
pshy.mapdb_maps["15"] = {author = "<b><o> Medium </o></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="83" Y="306" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="555" Y="191" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="429" Y="296" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="536" Y="35" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="393" Y="28" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="-13" Y="132" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="908" Y="241" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="1"/><S T="13" X="393" Y="150" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="4"/><S T="13" X="393" Y="150" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="-13" Y="132" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4" lua="3"/><S T="13" X="908" Y="241" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="393" Y="150" L="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="13" X="393" Y="150" L="10" P="1,0,0.3,0.2,10,0,0,0" c="4" lua="2"/><S T="12" X="54" Y="286" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="112" Y="286" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="83" Y="306" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="15" X="36" Y="131" L="52" H="252" P="0,0,0,0,0,0,0,0"/><S T="12" X="-13" Y="132" L="41" H="253" P="1,0,0.3,0.4,0,1,0,0" o="292020"/><S T="12" X="808" Y="255" L="242" H="12" P="0,0,0,0,10,0,0,0" o="292020"/><S T="12" X="829" Y="200" L="224" H="12" P="0,0,0,0,10,0,0,0" o="292020"/><S T="12" X="849" Y="233" L="175" H="69" P="0,0,0,0,10,0,0,0" o="292020" c="4" N=""/><S T="12" X="919" Y="245" L="11" H="44" P="0,0,0.3,30,10,0,0,0" o="292020"/><S T="12" X="908" Y="243" L="11" H="44" P="0,0,0,0,10,0,0,0" o="292020" lua="11"/><S T="12" X="930" Y="247" L="10" H="68" P="0,0,0.3,0.2,10,0,0,0" o="292020"/><S T="12" X="83" Y="287" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="393" Y="150" L="20" P="1,0,0.3,0.2,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="84" Y="261" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="15" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="16" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="9"/><JR M1="15" M2="11"/><JR M1="16" M2="12"/><JR M1="10" M2="14"/><JR M1="13" M2="17"/><JR M1="12" M2="32"/><JR M1="17" M2="32"/><JP M1="24" AXIS="-1,0" LIM1="0" LIM2="1.6736666417732602" MV="1000,1.6666666666666667"/><JR M1="14" M2="24"/><JR M1="11" M2="29"/><JD c="000000,3,1,1" P1="-20,263" P2="-12,267"/><JD c="000000,3,1,1" P1="738.61,210.6" P2="730.04,213.15"/><JD c="000000,3,1,1" P1="-10,263" P2="-2,267"/><JD c="000000,3,1,1" P1="728.76,208.86" P2="720.19,211.41"/><JD c="000000,3,1,1" P1="-20,271" P2="-12,267"/><JD c="000000,3,1,1" P1="737.22,218.47" P2="730.04,213.15"/><JD c="000000,3,1,1" P1="-10,271" P2="-2,267"/><JD c="000000,3,1,1" P1="727.37,216.74" P2="720.19,211.41"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "15")
pshy.mapdb_maps["15"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 16
pshy.mapdb_maps["16"] = {author = "<b><o> Medium </o></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="669" Y="318" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="290" Y="31" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="199" Y="31" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="59" Y="31" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="100" Y="31" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="290" Y="86" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="199" Y="86" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="1"/><S T="13" X="59" Y="86" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="4"/><S T="13" X="100" Y="82" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4"/><S T="13" X="290" Y="86" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="3"/><S T="13" X="199" Y="86" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="59" Y="86" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="100" Y="82" L="10" P="1,0,0.3,0.2,10,0,1,0" c="4" lua="2"/><S T="12" X="640" Y="298" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="698" Y="298" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="669" Y="318" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="100" Y="147" L="10" H="46" P="1,0,0,0,0,0,8,0" o="292020" c="2"/><S T="12" X="260" Y="286" L="10" H="46" P="1,0,0,0,0,0,8,0" o="292020" c="2"/><S T="12" X="180" Y="216" L="10" H="46" P="1,0,0,0,0,0,8,0" o="292020" c="2"/><S T="12" X="100" Y="176" L="10" H="100" P="1,0,0,0,-90,0,8,0" o="292020" c="2"/><S T="12" X="260" Y="315" L="10" H="100" P="1,0,0,0,-90,0,8,0" o="292020" c="2"/><S T="12" X="180" Y="245" L="10" H="100" P="1,0,0,0,-90,0,8,0" o="292020" c="2"/><S T="12" X="473" Y="303" L="316" H="10" P="1,99999,999,0,-10,1,0,0" o="292020" c="2"/><S T="13" X="199" Y="86" L="10" P="1,50,0,0,0,0,1,0" o="292020" c="2"/><S T="13" X="59" Y="86" L="10" P="1,40,0,0,0,0,1,0" o="292020" c="2"/><S T="13" X="290" Y="86" L="10" P="1,50,0,0,0,0,1,0" o="292020" c="2"/><S T="13" X="228" Y="232" L="15" P="0,0,0,0,0,1,Infinity,0" c="2" v="3500"/><S T="13" X="210" Y="304" L="15" P="0,0,0,0,0,1,Infinity,0" c="2" v="3500"/><S T="12" X="668" Y="299" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="100" Y="82" L="20" P="1,0,0.3,0,0,1,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="670" Y="273" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="15" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="16" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="13" M2="9"/><JR M1="15" M2="11"/><JR M1="16" M2="12"/><JR M1="10" M2="14"/><JR M1="13" M2="17"/><JD c="000000,3,1,1" P1="439.5,284.27" P2="447.98,287.12"/><JD c="000000,3,1,1" P1="449.4,282.88" P2="457.88,285.73"/><JD c="000000,3,1,1" P1="440.61,292.2" P2="447.98,287.12"/><JD c="000000,3,1,1" P1="450.52,290.8" P2="457.88,285.73"/><JR M1="23" M2="26" LIM1="0" LIM2="0"/><JR M1="24" M2="27" LIM1="0" LIM2="0"/><JR M1="25" M2="28" LIM1="0" LIM2="0"/><JR M2="23" P1="100,175.68" LIM1="-0.6981317007977318" LIM2="0.6981317007977318"/><JR M2="24" P1="260,315" LIM1="-0.6981317007977318" LIM2="0.6981317007977318"/><JR M2="25" P1="180,245" LIM1="-0.6981317007977318" LIM2="0.6981317007977318"/><JR M1="17" M2="36"/><JP M1="29" AXIS="-1,1" MV="Infinity,1.6666666666666667"/><JR M2="29"/><JR M1="11" M2="30"/><JR M1="12" M2="31"/><JR M1="14" M2="32"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "16")
pshy.mapdb_maps["16"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 17
pshy.mapdb_maps["17"] = {author = "<b><b><r> Hard </r></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;34,1;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="766" Y="328" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="422" Y="43" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="400" Y="190" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="491" Y="112" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="723" Y="194" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="737" Y="237" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4"/><S T="13" X="400" Y="241" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="491" Y="165" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="400" Y="241" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="1"/><S T="12" X="49" Y="47" L="10" H="39" P="0,0,0.3,0.2,40,0,0,0" o="451B20" v="5000"/><S T="12" X="750" Y="50" L="10" H="39" P="0,0,0.3,0.2,-30,0,0,0" o="451B20" v="5000"/><S T="13" X="737" Y="237" L="10" P="1,0,0.3,0.2,-10,0,1,0" c="4" lua="2"/><S T="13" X="422" Y="86" L="10" P="1,100,0,0,540,0,1,0" c="4"/><S T="13" X="422" Y="86" L="10" P="1,100,0,0,540,0,1,0" c="4" lua="3"/><S T="12" X="737" Y="308" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="13" X="491" Y="165" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="4"/><S T="12" X="795" Y="308" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="766" Y="328" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="13" X="29" Y="36" L="20" P="1,0,0.3,0,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/><S T="13" X="775" Y="36" L="20" P="1,0,0.3,0,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/><S T="12" X="43" Y="67" L="77" H="11" P="0,0,0.3,0,30,0,0,0" o="292020"/><S T="12" X="763" Y="223" L="77" H="11" P="1,0,0,0,-30,0,0,0" o="451B20"/><S T="12" X="763" Y="68" L="73" H="10" P="0,0,0.3,0,-30,0,0,0" o="292020"/><S T="12" X="348" Y="85" L="127" H="10" P="0,0,0,0,540,0,0,0" o="292020"/><S T="12" X="141" Y="85" L="140" H="10" P="0,0,0,0,0,0,0,0" o="292020"/><S T="12" X="634" Y="164" L="270" H="10" P="0,0,0,0,0,0,0,0" o="292020"/><S T="12" X="611" Y="241" L="236" H="10" P="0,0,0,0,0,0,0,0" o="292020"/><S T="12" X="623" Y="85" L="222" H="10" P="0,0,0,0,540,0,0,0" o="292020"/><S T="12" X="218" Y="164" L="357" H="10" P="0,0,0,0,0,0,0,0" o="292020"/><S T="12" X="331" Y="241" L="122" H="10" P="0,0,0,0,0,0,0,0" o="292020"/><S T="12" X="107" Y="243" L="174" H="10" P="0,0,0,0,0,0,0,0" o="292020"/><S T="12" X="462" Y="85" L="100" H="10" P="1,0,0,0,540,0,0,0" o="451B20" c="2"/><S T="12" X="447" Y="164" L="100" H="10" P="1,0,0,0,0,0,0,0" o="451B20" c="2"/><S T="12" X="443" Y="241" L="100" H="10" P="1,0,0,0,0,0,0,0" o="451B20" c="2"/><S T="12" X="422" Y="86" L="18" H="10" P="1,0,0.3,0.2,540,0,0,0" c="4"/><S T="12" X="491" Y="165" L="18" H="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="12" X="400" Y="241" L="18" H="10" P="1,0,0.3,0.2,0,0,0,0" c="4"/><S T="12" X="737" Y="237" L="18" H="10" P="1,0,0.3,0.2,-20,0,0,0" c="4"/><S T="12" X="529" Y="241" L="73" H="10" P="0,0,20,0,0,0,0,0" c="2"/><S T="12" X="765" Y="309" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="765" Y="269" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="17" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="11" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="12" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="9"/><JR M1="11" M2="13"/><JR M1="12" M2="20"/><JR M1="17" M2="18"/><JR M1="10" M2="16"/><JD c="000000,3,1,1" P1="439.5,484.27" P2="447.98,487.12"/><JD c="000000,3,1,1" P1="449.4,482.88" P2="457.88,485.73"/><JD c="000000,3,1,1" P1="440.61,492.2" P2="447.98,487.12"/><JD c="000000,3,1,1" P1="450.52,490.8" P2="457.88,485.73"/><JR M1="38" M2="41"/><JR M1="39" M2="42"/><JR M1="18" M2="41"/><JR M1="20" M2="42"/><JR M1="16" M2="44"/><JR M1="13" M2="43"/><JR M1="40" P1="489.84,240.75" LIM1="-Infinity" LIM2="1.5707963267948966"/><JR M1="28" P1="794.22,206.75" LIM1="-Infinity" LIM2="1.1344640137963142"/><JR M1="39" P1="400,164.52" LIM1="-1.5707963267948966" LIM2="Infinity"/><JR M1="38" P1="509.43,83.79" LIM1="-Infinity" LIM2="1.0471975511965976"/><JR M1="40" M2="43"/><JR M1="28" M2="44"/><JD c="ffd78a,5,1,1" P1="488.52,240.52" P2="488.52,241.52"/><JD c="ffd78a,5,1,1" P1="399.45,163.96" P2="399.45,164.96"/><JD c="ffd78a,5,1,1" P1="507.89,85.21" P2="507.89,86.21"/><JD c="ffd78a,5,1,1" P1="792.89,206.77" P2="792.27,207.46"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "17")
pshy.mapdb_maps["17"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 18
pshy.mapdb_maps["18"] = {author = "<b><r> Hard </r></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="739" Y="363" L="58" H="10" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="562" Y="344" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="12" X="179" Y="449" L="20" H="20" P="1,1000000000000,0.3,0.2,0,1,0,0"/><S T="12" X="731" Y="363" L="58" H="10" P="1,1000000,0,0,-270,1,0,0" o="BC0C0C"/><S T="12" X="179" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0"/><S T="12" X="179" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0"/><S T="12" X="123" Y="107" L="35" H="10" P="1,0,20,0,0,1,0,0"/><S T="13" X="603" Y="85" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="297" Y="115" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="771" Y="45" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="747" Y="137" L="10" P="1,0,0.3,0.2,0,0,0,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="742" Y="175" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4"/><S T="13" X="762" Y="92" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4"/><S T="13" X="357" Y="307" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="762" Y="92" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="357" Y="307" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="1"/><S T="13" X="742" Y="175" L="10" P="1,0,0.3,0.2,10,0,1,0" c="4" lua="2"/><S T="13" X="762" Y="92" L="10" P="1,0,0.3,0.2,10,0,1,0" c="4" lua="22"/><S T="13" X="563" Y="246" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="563" Y="246" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="3"/><S T="12" X="533" Y="324" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20" c="2"/><S T="12" X="95" Y="89" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="13" X="762" Y="92" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="4"/><S T="12" X="591" Y="324" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20" c="2"/><S T="12" X="153" Y="89" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="562" Y="344" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="4"/><S T="12" X="124" Y="108" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="561" Y="325" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="12" X="123" Y="90" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="762" Y="92" L="20" P="1,0,0.3,0,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/><S T="13" X="741" Y="176" L="20" P="1,0,0.3,0,0,0,0,0" o="324650" c="2" i="-23,-30,17eb2ae7c0c.png"/><S T="12" X="631" Y="139" L="300" H="10" P="0,0,0.5,0.2,-9,0,0,0" o="292020"/><S T="9" X="309" Y="158" L="355" H="24" P="0,0,0,0,0,0,0,0"/><S T="12" X="167" Y="116" L="10" H="76" P="1,0,0.3,0.2,180,0,0,0" o="373030"/><S T="12" X="563" Y="245" L="70" H="10" P="1,1000,0.3,0.2,0,0,0,0" o="373030"/><S T="12" X="10" Y="114" L="10" H="221" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="51" Y="220" L="10" H="85" P="0,0,0.3,0.2,-90,0,0,0" o="292020"/><S T="12" X="49" Y="27" L="10" H="91" P="0,0,0.3,0.2,-120,0,0,0" o="292020"/><S T="12" X="41" Y="21" L="10" H="67" P="0,0,0.3,0.2,-120,0,0,0" o="292020"/><S T="12" X="32" Y="15" L="10" H="55" P="0,0,0.3,0.2,-120,0,0,0" o="292020"/><S T="12" X="28" Y="11" L="10" H="30" P="0,0,0.3,0.2,-120,0,0,0" o="292020"/><S T="9" X="53" Y="108" L="75" H="213" P="0,0,0,0,0,0,0,0"/><S T="12" X="433" Y="308" L="186" H="10" P="1,0,0.3,0.2,0,0,0,0" o="373030" c="2"/><S T="12" X="357" Y="309" L="22" H="10" P="1,0,0.3,0.2,0,1,0,0" c="2" lua="11"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="563" Y="299" C="0" P="0"/><O X="125" Y="64" C="0" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JR M1="6"/><JP M1="7" AXIS="0,1"/><JR M1="7" M2="6"/><JP M1="8" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="8" M2="7"/><JP M1="10" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="10" M2="9"/><JD c="584141,3,1,0" AMP="1" M1="22" M2="11"/><JD c="584141,3,1,0" AMP="1" M1="17" M2="12"/><JD c="584141,3,1,0" AMP="1" M1="18" M2="13"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="15" M2="14"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="16" M2="14"/><JR M1="17" M2="19"/><JR M1="18" M2="26"/><JR M1="22" M2="23"/><JR M1="15" M2="20"/><JD c="000000,3,1,1" P1="320.29,302.51" P2="327,296.59"/><JD c="000000,3,1,1" P1="183.53,124.49" P2="187.25,116.36"/><JD c="000000,3,1,1" P1="559.53,266.37" P2="563.25,274.5"/><JD c="000000,3,1,1" P1="324.04,293.24" P2="330.75,287.32"/><JD c="000000,3,1,1" P1="183.19,114.5" P2="186.91,106.37"/><JD c="000000,3,1,1" P1="559.19,276.36" P2="562.91,284.49"/><JD c="000000,3,1,1" P1="327.72,305.51" P2="327,296.59"/><JD c="000000,3,1,1" P1="191.54,124.22" P2="187.25,116.36"/><JD c="000000,3,1,1" P1="567.54,266.64" P2="563.25,274.5"/><JD c="000000,3,1,1" P1="331.46,296.23" P2="330.75,287.32"/><JD c="000000,3,1,1" P1="191.18,114.21" P2="186.91,106.37"/><JD c="000000,3,1,1" P1="567.18,276.64" P2="562.91,284.49"/><JR M1="16" M2="21"/><JR M1="21" M2="35"/><JR M1="20" M2="36"/><JP M1="39" AXIS="0,1"/><JP M1="40" AXIS="0,1" LIM1="-1.9333333333333333" LIM2="15"/><JPL c="A89292,2,1,0" M1="39" M2="40" P3="164.7,-37.38" P4="564,115"/><JR M1="23" M2="40"/><JR M2="48" P1="525.13,308.13" LIM1="-Infinity" LIM2="0.3490658503988659" MV="9000,0.7853981633974483"/><JR M1="19" M2="49"/><JR M1="49" M2="48"/><JR M1="26" M2="35"/><JD c="ffd78a,5,1,1" M1="48" M2="48" P1="521.34,308.42" P2="521.34,309.42"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "18")
pshy.mapdb_maps["18"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 19
pshy.mapdb_maps["19"] = {author = "<b><r> Hard </r></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="33" Y="229" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="611" Y="63" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="468" Y="173" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="316" Y="156" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="764" Y="179" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="805" Y="-8" L="10" P="1,50,0.3,0.2,0,0,1,0" c="4"/><S T="13" X="810" Y="314" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="402" Y="60" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="810" Y="314" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="1"/><S T="13" X="805" Y="-8" L="10" P="1,50,0.3,0.2,10,0,1,0" c="4" lua="2"/><S T="13" X="611" Y="97" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="611" Y="97" L="10" P="1,50,0,0,0,0,1,0" o="324650" c="4" N="" m="" lua="3"/><S T="12" X="4" Y="209" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="344" Y="309" L="10" H="36" P="1,1000,0.3,0.2,0,1,0,0" o="2E190C" c="2"/><S T="12" X="584" Y="139" L="10" H="36" P="1,1000,0.3,0.2,0,1,0,0" o="2E190C" c="2"/><S T="13" X="402" Y="60" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="4"/><S T="12" X="62" Y="209" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20"/><S T="12" X="402" Y="309" L="10" H="36" P="1,1000,0.3,0.2,0,1,0,0" o="2E190C" c="2"/><S T="12" X="642" Y="139" L="10" H="36" P="1,1000,0.3,0.2,0,1,0,0" o="2E190C" c="2"/><S T="12" X="33" Y="229" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="3"/><S T="12" X="373" Y="329" L="10" H="68" P="1,1000,0.3,0.2,-90,1,0,0" o="2E190C" c="2"/><S T="12" X="613" Y="159" L="10" H="68" P="1,1000,0.3,0.2,-90,1,0,0" o="2E190C" c="2"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="32" Y="210" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="23" Y="278" L="20" P="1,0,0.3,0,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/><S T="13" X="23" Y="278" L="18" P="1,0,0.3,0.2,0,1,0,0" o="324650" c="4" v="6000" m=""/><S T="12" X="183" Y="252" L="281" H="10" P="0,0,5,0.2,-20,0,0,0" o="292020"/><S T="9" X="374" Y="56" L="66" H="114" P="0,0,0,0,0,0,0,0"/><S T="12" X="374" Y="38" L="73" H="10" P="1,0,0,0,400,0,0,0" o="2E190C"/><S T="12" X="752" Y="316" L="145" H="10" P="0,0,0.3,0,20,0,0,0" o="292020"/><S T="12" X="806" Y="270" L="75" H="10" P="0,0,0.3,0.2,20,0,0,0" o="292020"/><S T="12" X="831" Y="312" L="71" H="10" P="0,0,0.3,0.2,110,0,0,0" o="292020"/><S T="12" X="408" Y="-6" L="814" H="10" P="1,0,0,0,0,0,0,0" o="2E190C"/><S T="9" X="544" Y="26" L="276" H="52" P="0,0,0,0,0,0,0,0"/><S T="12" X="825" Y="313" L="11" H="41" P="0,0,0.3,20,20,0,0,0" o="324650"/><S T="12" X="816" Y="310" L="11" H="41" P="0,0,0,0,20,0,0,0" o="324650" lua="11"/><S T="12" X="27" Y="300" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="9" X="423" Y="67" L="34" H="34" P="0,0,0,0,0,0,0,0"/><S T="12" X="798" Y="299" L="82" H="70" P="0,0,0.3,0.2,20,0,0,0" o="292020" c="4"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="34" Y="184" C="0" P="0"/><O X="23" Y="278" C="15" Mp="100" Mv="40" P="0"/><O X="23" Y="278" C="14" Mp="500" Mv="3" P="0"/><O X="611" Y="97" C="10" P="0"/><O X="611" Y="97" C="22" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JPL c="C9E467,3,1,0" M1="25" M2="26" P3="374.54,30" P4="614.54,30"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="15" M2="6"/><JD c="584141,3,1,0" AMP="1" HZ="5" M1="11" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="12" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="9"/><JR M1="11" M2="13"/><JR M1="12" M2="20"/><JR M1="15" M2="16"/><JR M1="10" M2="14"/><JD c="000000,3,1,1" P1="834.53,5.13" P2="837.38,-3.35"/><JD c="000000,3,1,1" P1="743.79,263.33" P2="737.2,257.28"/><JD c="000000,3,1,1" P1="330.49,43.73" P2="335.16,36.1"/><JD c="000000,3,1,1" P1="833.14,-4.77" P2="835.99,-13.25"/><JD c="000000,3,1,1" P1="734.18,260.58" P2="727.6,254.52"/><JD c="000000,3,1,1" P1="419.67,97.7" P2="410.73,98.08"/><JD c="000000,3,1,1" P1="842.46,4.02" P2="837.38,-3.35"/><JD c="000000,3,1,1" P1="746,255.64" P2="737.2,257.28"/><JD c="000000,3,1,1" P1="326.25,36.94" P2="335.16,36.1"/><JD c="000000,3,1,1" P1="841.06,-5.89" P2="835.99,-13.25"/><JD c="000000,3,1,1" P1="736.38,252.89" P2="727.6,254.52"/><JD c="000000,3,1,1" P1="415.78,90.71" P2="410.73,98.08"/><JR M1="25" M2="18"/><JR M1="26" M2="19"/><JR M1="25" M2="22"/><JR M1="26" M2="23"/><JR M1="18" M2="22"/><JR M1="19" M2="23"/><JP M1="25" AXIS="0,1" LIM1="0" LIM2="6.933333333333334"/><JP M1="26" AXIS="0,1" LIM1="-6.3188861766638444" LIM2="0.014447156669488486"/><JR M2="34" P1="373.44,37.02" LIM1="-3.141592653589793" LIM2="Infinity" MV="Infinity,-0.7853981633974483"/><JR M1="20" M2="34" LIM1="0" LIM2="0"/><JR M1="13" M2="41"/><JR M2="38" P1="0,-5" LIM1="-4.71238898038469" LIM2="Infinity" MV="50000,-1.7453292519943295"/><JR M1="14" M2="38" LIM1="0" LIM2="0"/><JR M1="10" M2="9"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "19")
pshy.mapdb_maps["19"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}

--map 20
pshy.mapdb_maps["20"] = {author = "<b><r> Hard </r></b>", shamans = 0, autoskip = false, xml = [[<C><P mc="" MEDATA=";;;;-0;0::0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48:1-"/><Z><S><S T="12" X="400" Y="400" L="800" H="16" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="76" Y="448" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="2"/><S T="12" X="737" Y="363" L="58" H="14" P="1,1000000,0,0,-90,1,0,0" o="FB0000" c="3"/><S T="12" X="76" Y="481" L="20" H="20" P="1,1000000000000,0,0,0,1,0,0" c="4"/><S T="12" X="76" Y="422" L="80" H="20" P="1,0,0,0,0,1,0,0" c="2"/><S T="12" X="51" Y="317" L="26" H="10" P="1,0,20,0,0,1,0,0" c="2"/><S T="13" X="550" Y="176" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="00FF2F" c="4" i="-13,-12,17ea2bfde60.png"/><S T="13" X="151" Y="250" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="ED0000" c="4" i="-14,-12,17ea2befa39.png"/><S T="13" X="452" Y="296" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="1400FF" c="4" i="-13,-12,17ea2c02a61.png"/><S T="13" X="350" Y="54" L="10" P="0,9999999,0.3,0.2,0,1,Infinity,0" o="FF8A00" c="4" i="-14,-12,17ea2bf9260.png"/><S T="13" X="350" Y="125" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4"/><S T="13" X="150" Y="200" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="450" Y="163" L="10" P="1,50,0,0,0,0,1,0" c="4"/><S T="13" X="150" Y="200" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="1"/><S T="13" X="350" Y="125" L="10" P="1,0,0.3,0.2,0,0,1,0" c="4" lua="2"/><S T="13" X="550" Y="125" L="10" P="1,100,0,0,0,0,1,0" c="4"/><S T="13" X="550" Y="126" L="10" P="1,100,0,0,0,0,1,0" c="4" lua="3"/><S T="12" X="22" Y="297" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20" c="2"/><S T="13" X="450" Y="163" L="10" P="1,50,0,0,0,0,1,0" c="4" lua="4"/><S T="12" X="80" Y="297" L="10" H="36" P="0,0,0.3,0.2,0,0,0,0" o="451B20" c="2"/><S T="12" X="51" Y="317" L="10" H="68" P="0,0,0.3,0.2,-90,0,0,0" o="451B20" c="4"/><S T="12" X="772" Y="339" L="56" H="10" P="0,0,0.3,0.2,0,0,0,0" o="292020"/><S T="12" X="795" Y="365" L="54" H="10" P="0,0,0.3,0.2,90,0,0,0" o="292020"/><S T="12" X="50" Y="298" L="44" H="20" P="0,0,0.3,0.2,0,0,0,0" o="324650" c="4" i="0,0,17eb2ae2806.png"/><S T="13" X="779" Y="178" L="20" P="1,0,10,0,0,0,0,0" o="324650" i="-23,-30,17eb2ae7c0c.png"/><S T="12" X="701" Y="200" L="200" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="50" Y="200" L="100" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="250" Y="275" L="100" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="222" Y="125" L="45" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="422" Y="125" L="45" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="222" Y="200" L="45" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="422" Y="200" L="45" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="278" Y="125" L="45" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="478" Y="125" L="45" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="746" Y="175" L="45" H="10" P="0,0,10,0,-90,0,0,0" o="292020" v="5000"/><S T="12" X="278" Y="200" L="45" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="478" Y="200" L="45" H="10" P="0,0,10,0,0,0,0,0" o="292020"/><S T="12" X="350" Y="275" L="99" H="10" P="1,0,10,0,0,1,2,0" o="9B9B9B" c="2"/><S T="12" X="150" Y="275" L="99" H="10" P="1,0,10,0,0,1,2,0" o="9B9B9B" c="2"/><S T="12" X="150" Y="200" L="99" H="10" P="1,0,10,0,0,1,2,0" o="9B9B9B"/><S T="12" X="350" Y="125" L="99" H="10" P="1,0,10,0,0,1,2,0" o="9B9B9B"/><S T="12" X="150" Y="125" L="99" H="10" P="1,0,10,0,0,1,2,0" o="9B9B9B"/><S T="12" X="250" Y="93" L="85" H="10" P="1,0,10,0,-90,1,0,0" o="9B9B9B"/><S T="12" X="450" Y="163" L="85" H="10" P="1,0,10,0,-90,1,0,0" o="878787"/><S T="12" X="350" Y="200" L="99" H="10" P="1,0,10,0,0,1,2,0" o="9B9B9B"/><S T="12" X="550" Y="125" L="99" H="10" P="1,0,10,0,0,1,0,0" o="9B9B9B"/><S T="12" X="550" Y="200" L="99" H="10" P="1,0,10,0,0,1,0,0" o="9B9B9B"/><S T="13" X="779" Y="178" L="13" P="1,100,0.3,0.2,0,1,0,0" o="324650" c="4" m=""/><S T="15" X="250" Y="238" L="97" H="64" P="0,0,0,0,0,0,0,0"/></S><D><F X="766" Y="385"/><T X="767" Y="392"/><DS X="400" Y="375"/></D><O><O X="52" Y="272" C="0" P="0"/><O X="779" Y="178" C="16" Mp="100" Mv="-2" P="0"/></O><L><JR M1="1"/><JP M1="2" AXIS="0,1"/><JR M1="2" M2="1"/><JP M1="3" AXIS="0,1" LIM1="-100" LIM2="0" MV="Infinity,-1000000"/><JR M1="3" M2="2"/><JP M1="5" AXIS="0,1" LIM1="-1" LIM2="0" MV="867,0"/><JR M1="5" M2="4"/><JD c="584141,3,1,0" AMP="1" M1="15" M2="6"/><JD c="584141,3,1,0" AMP="1" M1="11" M2="7"/><JD c="584141,3,1,0" AMP="1" M1="12" M2="8"/><JD c="584141,3,1,0" AMP="1" M1="10" M2="9"/><JR M1="11" M2="13"/><JR M1="12" M2="18"/><JR M1="15" M2="16"/><JR M1="10" M2="14"/><JD c="000000,3,1,1" P1="155.12,191.53" P2="151.12,199.53"/><JD c="000000,3,1,1" P1="355.12,191.53" P2="351.12,199.53"/><JD c="000000,3,1,1" P1="554.12,209.53" P2="550.12,201.53"/><JD c="322828,3,1,1" M1="43" M2="43" P1="454.12,172.53" P2="450.12,164.53"/><JD c="322828,3,1,1" M1="42" M2="42" P1="254.12,84.53" P2="250.12,92.53"/><JD c="000000,3,1,1" P1="155.12,201.53" P2="151.12,209.53"/><JD c="000000,3,1,1" P1="355.12,201.53" P2="351.12,209.53"/><JD c="000000,3,1,1" P1="554.12,199.53" P2="550.12,191.53"/><JD c="322828,3,1,1" M1="43" M2="43" P1="454.12,162.53" P2="450.12,154.53"/><JD c="322828,3,1,1" M1="42" M2="42" P1="254.12,94.53" P2="250.12,102.53"/><JD c="000000,3,1,1" P1="147.11,191.53" P2="151.12,199.53"/><JD c="000000,3,1,1" P1="347.11,191.53" P2="351.12,199.53"/><JD c="000000,3,1,1" P1="546.11,209.53" P2="550.12,201.53"/><JD c="322828,3,1,1" M1="43" M2="43" P1="446.11,172.53" P2="450.12,164.53"/><JD c="322828,3,1,1" M1="42" M2="42" P1="246.11,84.53" P2="250.12,92.53"/><JD c="000000,3,1,1" P1="147.12,201.53" P2="151.12,209.53"/><JD c="000000,3,1,1" P1="347.12,201.53" P2="351.12,209.53"/><JD c="000000,3,1,1" P1="546.12,199.53" P2="550.12,191.53"/><JD c="322828,3,1,1" M1="43" M2="43" P1="446.12,162.53" P2="450.12,154.53"/><JD c="322828,3,1,1" M1="42" M2="42" P1="246.12,94.53" P2="250.12,102.53"/><JR M1="41" M2="38"/><JR M1="40" M2="44"/><JR M1="44" M2="37"/><JR M1="45" M2="46"/><JP M1="39" AXIS="0,1" LIM1="-2.5" LIM2="0"/><JP M1="44" AXIS="0,1" LIM1="-2.5" LIM2="0"/><JP M1="46" AXIS="0,1" LIM1="0" LIM2="2.5" MV="5000,1.6666666666666667"/><JR M1="18" M2="43"/><JR M1="14" M2="40"/><JR M1="13" M2="39"/><JR M1="39" M2="41"/><JP M1="42" AXIS="0,1" LIM1="-2.466666666666667" LIM2="0" MV="2000,-1.6666666666666667"/><JR M1="16" M2="45"/><JPL c="B18181,2,1,0" M1="42" M2="43" P3="250,21" P4="450,21"/></L></Z></C>]], background_color = "#797471"}
tabinsert(maps, "20")
pshy.mapdb_maps["20"].bonuses = {
{type = "BonusRemoveGround", image = "17d0739e454.png", x = 30, y = 375, remove_ground_id = {1, 11, 111 ,1111}};
{type = "BonusRemoveGround", image = "17d0b98f194.png", x = 90, y = 375, remove_ground_id = {2, 22 ,222 ,2222}};
{type = "BonusRemoveGround", image = "17d0b990904.png", x = 150, y = 375, remove_ground_id = {3, 33, 333 ,3333}};
{type = "BonusRemoveGround", image = "17d0b992075.png", x = 210, y = 375, remove_ground_id = {4, 44, 444, 4444}};
}
--- Rotation:
pshy.mapdb_rotations["chickengame_pshy"]	= {desc = "", shamans = 0, autoskip = false, is_random = false, items = maps}
if __IS_MAIN_MODULE__ then
	eventPlayerWon = function()
		tfm.exec.newGame()
		 
	end
	eventPlayerBonusGrabbed = function(player_name, id)
		for other_player_name in pairs(tfm.get.room.playerList) do
			if other_player_name ~= player_name then
				tfm.exec.killPlayer(other_player_name)
			end
		end
		local sync_player = tfm.exec.getPlayerSync()
		if sync_player ~= nil and sync_player ~= player_name then
			tfm.exec.setPlayerSync(player_name)
		end
	end
end
function eventInit()
	if __IS_MAIN_MODULE__ then
		tfm.exec.disableAfkDeath()
		tfm.exec.disablePhysicalConsumables()
		pshy.newgame_ChatCommandRotc(nil, "chickengame_pshy")
		tfm.exec.newGame()

		tfm.exec.chatMessage("<b><o>====<ch2>Chicken Puzzle</ch2>====</o></b>")
		tfm.exec.chatMessage("<b><o>This game is singleplayer!</o></b>")
		tfm.exec.chatMessage("<b><o>Every round, the first player to press a button is set as sync and others are killed.</o></b>")
		tfm.exec.chatMessage("<j>Help the chicken to return to its eggs.</j>")
		tfm.exec.chatMessage("<ch><ch2>!replay</ch2> or <ch2>!r</ch2> to retry the map.</ch>")
		tfm.exec.chatMessage("<ch><ch2>!skip</ch2> to skip the level.</ch>")
		tfm.exec.chatMessage("<ch><ch2>!admin</ch2> to allow a player to use every command.</ch>")
		tfm.exec.chatMessage("<ch><ch2>!map 1-20</ch2> to choose map level.</ch>")

	end
end
end
new_mod.Content()
pshy.merge_ModuleEnd()
pshy.merge_Finish()